<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Dynamic rendering in Vulkan 1.3 | Matej Elias</title>
<meta name=keywords content="c++,vulkan,computer-graphics"><meta name=description content="Exploring dynamic rendering feature of Vulkan 1.3 which aims to simplify rendering by removing need for VkRenderPass and VkFramebuffer objects"><meta name=author content="Matej Elias"><link rel=canonical href=http://localhost:1313/posts/vulkan-dynamic-rendering/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/vulkan-dynamic-rendering/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://localhost:1313/posts/vulkan-dynamic-rendering/"><meta property="og:site_name" content="Matej Elias"><meta property="og:title" content="Dynamic rendering in Vulkan 1.3"><meta property="og:description" content="Exploring dynamic rendering feature of Vulkan 1.3 which aims to simplify rendering by removing need for VkRenderPass and VkFramebuffer objects"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-02T10:00:00+01:00"><meta property="article:modified_time" content="2025-01-02T10:00:00+01:00"><meta property="article:tag" content="C++"><meta property="article:tag" content="Vulkan"><meta property="article:tag" content="Computer-Graphics"><meta name=twitter:card content="summary"><meta name=twitter:title content="Dynamic rendering in Vulkan 1.3"><meta name=twitter:description content="Exploring dynamic rendering feature of Vulkan 1.3 which aims to simplify rendering by removing need for VkRenderPass and VkFramebuffer objects"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Dynamic rendering in Vulkan 1.3","item":"http://localhost:1313/posts/vulkan-dynamic-rendering/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Dynamic rendering in Vulkan 1.3","name":"Dynamic rendering in Vulkan 1.3","description":"Exploring dynamic rendering feature of Vulkan 1.3 which aims to simplify rendering by removing need for VkRenderPass and VkFramebuffer objects","keywords":["c++","vulkan","computer-graphics"],"articleBody":"Introduction In this article, we explore the VK_KHR_dynamic_rendering extension, which eliminates the need for VkRenderPass and VkFramebuffer objects. By using this extension, rendering attachments (commonly referred to as render targets in other APIs) can be directly referenced before rendering begins.\nHow It Works Before Dynamic Rendering Previously, Vulkan required you to create a render pass, specifying the types of attachments to be used. Subpass dependencies could also be defined to handle attachment transitions after the render pass finishes. For example, a subpass could transition a color attachment from VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL to VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, allowing the attachment to be used as input in another pass.\nAdditionally, a framebuffer object representing the actual attachment images (via their views) had to be created. This framebuffer was statically linked to a specific render pass. For a single logical rendering pass, you needed both a VkRenderPass and a VkFramebuffer, which had to be properly disposed of when no longer needed. Here’s how this process looked in code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 // Use subpass dependencies for attachment layout transitions std::array\u003cVkSubpassDependency, 2\u003e dependencies{}; // Define the dependencies... // Create render pass VkRenderPassCreateInfo renderPassInfo = {}; renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO; renderPassInfo.pAttachments = attachmentDescriptions.data(); renderPassInfo.attachmentCount = static_cast\u003cuint32_t\u003e(attachmentDescriptions.size()); renderPassInfo.subpassCount = 1; renderPassInfo.pSubpasses = \u0026subpass; renderPassInfo.dependencyCount = 2; renderPassInfo.pDependencies = dependencies.data(); if (vkCreateRenderPass(device.device(), \u0026renderPassInfo, nullptr, \u0026renderPass) != VK_SUCCESS) { throw std::runtime_error(\"Failed to create render pass\"); } // Create the framebuffer VkFramebufferCreateInfo framebufferInfo = {}; framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO; framebufferInfo.renderPass = renderPass; // Requires render pass framebufferInfo.pAttachments = attachmentViews.data(); framebufferInfo.attachmentCount = static_cast\u003cuint32_t\u003e(attachmentViews.size()); framebufferInfo.width = width; framebufferInfo.height = height; framebufferInfo.layers = maxLayers; if (vkCreateFramebuffer(device.device(), \u0026framebufferInfo, nullptr, \u0026framebuffer) != VK_SUCCESS) { throw std::runtime_error(\"Failed to create framebuffer\"); } // Begin the render pass VkRenderPassBeginInfo renderPassBeginInfo = Init::renderPassBeginInfo(); renderPassBeginInfo.renderPass = renderPass; renderPassBeginInfo.framebuffer = framebuffer; renderPassBeginInfo.renderArea.extent.width = width; renderPassBeginInfo.renderArea.extent.height = height; renderPassBeginInfo.clearValueCount = 3; renderPassBeginInfo.pClearValues = clearValues.data(); vkCmdBeginRenderPass(drawCmdBuffer, \u0026renderPassBeginInfo, VK_SUBPASS_CONTENTS_INLINE); // Draw the scene vkCmdEndRenderPass(drawCmdBuffer); Note on Graphics Pipelines When creating a graphics pipeline, the VkGraphicsPipelineCreateInfo structure required a valid render pass object. As a result, pipelines were directly tied to specific render passes.\nWith Dynamic Rendering Dynamic rendering eliminates the need for both render pass and framebuffer objects. Instead, attachments are described using the VkRenderingAttachmentInfoKHR structure:\n1 2 3 4 5 6 7 VkRenderingAttachmentInfoKHR attachmentInfo{}; attachmentInfo.sType = VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR; attachmentInfo.imageView = colorAttachment.view; attachmentInfo.imageLayout = colorAttachment.layout; attachmentInfo.loadOp = access.loadOp; attachmentInfo.storeOp = access.storeOp; attachmentInfo.clearValue = {...}; Rendering begins with the VkRenderingInfoKHR structure and the vkCmdBeginRenderingKHR command:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 VkRenderingInfoKHR renderingInfo{VK_STRUCTURE_TYPE_RENDERING_INFO_KHR}; renderingInfo.renderArea = {...}; renderingInfo.layerCount = 1; renderingInfo.colorAttachmentCount = colorAttachments.size(); renderingInfo.pColorAttachments = colorAttachments.data(); renderingInfo.pDepthAttachment = \u0026depthAttachment; renderingInfo.pStencilAttachment = VK_NULL_HANDLE; // Start dynamic rendering vkCmdBeginRenderingKHR(renderContext.getCurrentCommandBuffer(), \u0026renderingInfo); // Draw the scene // End rendering vkCmdEndRenderingKHR(renderContext.getCurrentCommandBuffer()); Looks simpler? It is.\nGraphics Pipelines Previously, pipeline objects required a pointer to a valid render pass. With dynamic rendering, you can simply set the renderPass field in VkGraphicsPipelineCreateInfo to VK_NULL_HANDLE. To support dynamic rendering, attach a VkPipelineRenderingCreateInfoKHR structure to the pNext field of VkGraphicsPipelineCreateInfo:\n1 2 3 4 5 6 7 8 9 10 11 VkPipelineRenderingCreateInfoKHR pipelineCreate{VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR}; pipelineCreate.pNext = VK_NULL_HANDLE; pipelineCreate.colorAttachmentCount = colorAttachmentFormats.size(); pipelineCreate.pColorAttachmentFormats = colorAttachmentFormats.data(); pipelineCreate.depthAttachmentFormat = depthFormat; pipelineCreate.stencilAttachmentFormat = depthFormat; // Use pNext to reference the pipelineCreate structure VkGraphicsPipelineCreateInfo graphicsCreate{VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO}; graphicsCreate.pNext = \u0026pipelineCreate; graphicsCreate.renderPass = VK_NULL_HANDLE; // Now optional And that’s it.\nBenefits Why use dynamic rendering? Here are some key advantages:\nSimplified API: Render passes add hidden complexity by automatically transitioning images, which can be hard to trace. Dynamic rendering exposes transitions directly, offering more control to developers.\nEase of Render Graph Implementation: Building a per-frame render graph (or frame graph) is challenging with static render passes and framebuffers. Dynamic rendering eliminates the need for object pooling and pass matching, reducing the workload.\nImproved Resource Management: Managing VkFramebuffer and VkRenderPass objects is cumbersome, especially when render target lifespans are unpredictable. Dynamic rendering simplifies this process and reduces CPU overhead.\nFlexibility in Pipeline Design: With dynamic rendering, pipelines are no longer tied to specific render passes. This decoupling allows greater flexibility when designing and reusing pipelines across different rendering setups.\nReduced Boilerplate Code: By removing the need for VkRenderPass and VkFramebuffer objects, dynamic rendering significantly reduces the amount of boilerplate code, making Vulkan applications easier to write and maintain.\nSimplified Attachment Management: Managing attachments is more intuitive with dynamic rendering. You can directly specify the attachments during rendering without needing to predefine them in a render pass.\nPerformance Considerations On desktop GPUs, performance differences between dynamic rendering and traditional render passes are negligible. While desktop GPUs can occasionally benefit from additional information provided by render passes, this is mostly relevant for mobile GPUs, where the driver optimizations are more pronounced.\nDynamic rendering is ideal when you don’t need the specific advantages of traditional render passes, providing a low-overhead, streamlined API for most applications.\nAdditional Reading Vulkan Do’s and Don’ts RDNA Performance Guide ","wordCount":"838","inLanguage":"en","datePublished":"2025-01-02T10:00:00+01:00","dateModified":"2025-01-02T10:00:00+01:00","author":{"@type":"Person","name":"Matej Elias"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/vulkan-dynamic-rendering/"},"publisher":{"@type":"Organization","name":"Matej Elias","logo":{"@type":"ImageObject","url":"http://localhost:1313/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Matej Elias (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Matej Elias</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/projects/ title=Projects><span>Projects</span></a></li><li><a href=http://localhost:1313/about title="About me"><span>About me</span></a></li><li><a href=http://localhost:1313/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://localhost:1313/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Dynamic rendering in Vulkan 1.3</h1><div class=post-description>Exploring dynamic rendering feature of Vulkan 1.3 which aims to simplify rendering by removing need for VkRenderPass and VkFramebuffer objects</div><div class=post-meta><span title='2025-01-02 10:00:00 +0100 CET'>January 2, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;838 words&nbsp;·&nbsp;Matej Elias&nbsp;|&nbsp;<a href=https://github.com/elliahu/elliahu.github.io/tree/master/content/posts/vulkan-dynamic-rendering/ rel="noopener noreferrer" target=_blank>Sugest changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#introduction aria-label=Introduction>Introduction</a></li><li><a href=#how-it-works aria-label="How It Works">How It Works</a><ul><li><a href=#before-dynamic-rendering aria-label="Before Dynamic Rendering">Before Dynamic Rendering</a><ul><li><a href=#note-on-graphics-pipelines aria-label="Note on Graphics Pipelines">Note on Graphics Pipelines</a></li></ul></li><li><a href=#with-dynamic-rendering aria-label="With Dynamic Rendering">With Dynamic Rendering</a><ul><li><a href=#graphics-pipelines aria-label="Graphics Pipelines">Graphics Pipelines</a></li></ul></li></ul></li><li><a href=#benefits aria-label=Benefits>Benefits</a></li><li><a href=#performance-considerations aria-label="Performance Considerations">Performance Considerations</a></li><li><a href=#additional-reading aria-label="Additional Reading">Additional Reading</a></li></ul></div></details></div><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>In this article, we explore the <code>VK_KHR_dynamic_rendering</code> extension, which eliminates the need for <code>VkRenderPass</code> and <code>VkFramebuffer</code> objects. By using this extension, rendering attachments (commonly referred to as render targets in other APIs) can be directly referenced before rendering begins.</p><h2 id=how-it-works>How It Works<a hidden class=anchor aria-hidden=true href=#how-it-works>#</a></h2><h3 id=before-dynamic-rendering>Before Dynamic Rendering<a hidden class=anchor aria-hidden=true href=#before-dynamic-rendering>#</a></h3><p>Previously, Vulkan required you to create a render pass, specifying the types of attachments to be used. Subpass dependencies could also be defined to handle attachment transitions after the render pass finishes. For example, a subpass could transition a color attachment from <code>VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</code> to <code>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</code>, allowing the attachment to be used as input in another pass.</p><p>Additionally, a framebuffer object representing the actual attachment images (via their views) had to be created. This framebuffer was statically linked to a specific render pass. For a single logical rendering pass, you needed both a <code>VkRenderPass</code> and a <code>VkFramebuffer</code>, which had to be properly disposed of when no longer needed. Here’s how this process looked in code:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Use subpass dependencies for attachment layout transitions
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>array</span><span class=o>&lt;</span><span class=n>VkSubpassDependency</span><span class=p>,</span> <span class=mi>2</span><span class=o>&gt;</span> <span class=n>dependencies</span><span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=c1>// Define the dependencies...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// Create render pass
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>VkRenderPassCreateInfo</span> <span class=n>renderPassInfo</span> <span class=o>=</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=n>renderPassInfo</span><span class=p>.</span><span class=n>sType</span> <span class=o>=</span> <span class=n>VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>renderPassInfo</span><span class=p>.</span><span class=n>pAttachments</span> <span class=o>=</span> <span class=n>attachmentDescriptions</span><span class=p>.</span><span class=n>data</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>renderPassInfo</span><span class=p>.</span><span class=n>attachmentCount</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>attachmentDescriptions</span><span class=p>.</span><span class=n>size</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=n>renderPassInfo</span><span class=p>.</span><span class=n>subpassCount</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>renderPassInfo</span><span class=p>.</span><span class=n>pSubpasses</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>subpass</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>renderPassInfo</span><span class=p>.</span><span class=n>dependencyCount</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>renderPassInfo</span><span class=p>.</span><span class=n>pDependencies</span> <span class=o>=</span> <span class=n>dependencies</span><span class=p>.</span><span class=n>data</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>vkCreateRenderPass</span><span class=p>(</span><span class=n>device</span><span class=p>.</span><span class=n>device</span><span class=p>(),</span> <span class=o>&amp;</span><span class=n>renderPassInfo</span><span class=p>,</span> <span class=k>nullptr</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>renderPass</span><span class=p>)</span> <span class=o>!=</span> <span class=n>VK_SUCCESS</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=n>std</span><span class=o>::</span><span class=n>runtime_error</span><span class=p>(</span><span class=s>&#34;Failed to create render pass&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Create the framebuffer
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>VkFramebufferCreateInfo</span> <span class=n>framebufferInfo</span> <span class=o>=</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=n>framebufferInfo</span><span class=p>.</span><span class=n>sType</span> <span class=o>=</span> <span class=n>VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>framebufferInfo</span><span class=p>.</span><span class=n>renderPass</span> <span class=o>=</span> <span class=n>renderPass</span><span class=p>;</span> <span class=c1>// Requires render pass
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>framebufferInfo</span><span class=p>.</span><span class=n>pAttachments</span> <span class=o>=</span> <span class=n>attachmentViews</span><span class=p>.</span><span class=n>data</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>framebufferInfo</span><span class=p>.</span><span class=n>attachmentCount</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>attachmentViews</span><span class=p>.</span><span class=n>size</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=n>framebufferInfo</span><span class=p>.</span><span class=n>width</span> <span class=o>=</span> <span class=n>width</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>framebufferInfo</span><span class=p>.</span><span class=n>height</span> <span class=o>=</span> <span class=n>height</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>framebufferInfo</span><span class=p>.</span><span class=n>layers</span> <span class=o>=</span> <span class=n>maxLayers</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>vkCreateFramebuffer</span><span class=p>(</span><span class=n>device</span><span class=p>.</span><span class=n>device</span><span class=p>(),</span> <span class=o>&amp;</span><span class=n>framebufferInfo</span><span class=p>,</span> <span class=k>nullptr</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>framebuffer</span><span class=p>)</span> <span class=o>!=</span> <span class=n>VK_SUCCESS</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=n>std</span><span class=o>::</span><span class=n>runtime_error</span><span class=p>(</span><span class=s>&#34;Failed to create framebuffer&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Begin the render pass
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>VkRenderPassBeginInfo</span> <span class=n>renderPassBeginInfo</span> <span class=o>=</span> <span class=n>Init</span><span class=o>::</span><span class=n>renderPassBeginInfo</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>renderPassBeginInfo</span><span class=p>.</span><span class=n>renderPass</span> <span class=o>=</span> <span class=n>renderPass</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>renderPassBeginInfo</span><span class=p>.</span><span class=n>framebuffer</span> <span class=o>=</span> <span class=n>framebuffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>renderPassBeginInfo</span><span class=p>.</span><span class=n>renderArea</span><span class=p>.</span><span class=n>extent</span><span class=p>.</span><span class=n>width</span> <span class=o>=</span> <span class=n>width</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>renderPassBeginInfo</span><span class=p>.</span><span class=n>renderArea</span><span class=p>.</span><span class=n>extent</span><span class=p>.</span><span class=n>height</span> <span class=o>=</span> <span class=n>height</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>renderPassBeginInfo</span><span class=p>.</span><span class=n>clearValueCount</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>renderPassBeginInfo</span><span class=p>.</span><span class=n>pClearValues</span> <span class=o>=</span> <span class=n>clearValues</span><span class=p>.</span><span class=n>data</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>vkCmdBeginRenderPass</span><span class=p>(</span><span class=n>drawCmdBuffer</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>renderPassBeginInfo</span><span class=p>,</span> <span class=n>VK_SUBPASS_CONTENTS_INLINE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Draw the scene
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>vkCmdEndRenderPass</span><span class=p>(</span><span class=n>drawCmdBuffer</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=note-on-graphics-pipelines>Note on Graphics Pipelines<a hidden class=anchor aria-hidden=true href=#note-on-graphics-pipelines>#</a></h4><p>When creating a graphics pipeline, the <code>VkGraphicsPipelineCreateInfo</code> structure required a valid render pass object. As a result, pipelines were directly tied to specific render passes.</p><h3 id=with-dynamic-rendering>With Dynamic Rendering<a hidden class=anchor aria-hidden=true href=#with-dynamic-rendering>#</a></h3><p>Dynamic rendering eliminates the need for both render pass and framebuffer objects. Instead, attachments are described using the <code>VkRenderingAttachmentInfoKHR</code> structure:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>VkRenderingAttachmentInfoKHR</span> <span class=n>attachmentInfo</span><span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=n>attachmentInfo</span><span class=p>.</span><span class=n>sType</span> <span class=o>=</span> <span class=n>VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>attachmentInfo</span><span class=p>.</span><span class=n>imageView</span> <span class=o>=</span> <span class=n>colorAttachment</span><span class=p>.</span><span class=n>view</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>attachmentInfo</span><span class=p>.</span><span class=n>imageLayout</span> <span class=o>=</span> <span class=n>colorAttachment</span><span class=p>.</span><span class=n>layout</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>attachmentInfo</span><span class=p>.</span><span class=n>loadOp</span> <span class=o>=</span> <span class=n>access</span><span class=p>.</span><span class=n>loadOp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>attachmentInfo</span><span class=p>.</span><span class=n>storeOp</span> <span class=o>=</span> <span class=n>access</span><span class=p>.</span><span class=n>storeOp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>attachmentInfo</span><span class=p>.</span><span class=n>clearValue</span> <span class=o>=</span> <span class=p>{...};</span>
</span></span></code></pre></td></tr></table></div></div><p>Rendering begins with the <code>VkRenderingInfoKHR</code> structure and the <code>vkCmdBeginRenderingKHR</code> command:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>VkRenderingInfoKHR</span> <span class=n>renderingInfo</span><span class=p>{</span><span class=n>VK_STRUCTURE_TYPE_RENDERING_INFO_KHR</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>renderingInfo</span><span class=p>.</span><span class=n>renderArea</span> <span class=o>=</span> <span class=p>{...};</span>
</span></span><span class=line><span class=cl><span class=n>renderingInfo</span><span class=p>.</span><span class=n>layerCount</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>renderingInfo</span><span class=p>.</span><span class=n>colorAttachmentCount</span> <span class=o>=</span> <span class=n>colorAttachments</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>renderingInfo</span><span class=p>.</span><span class=n>pColorAttachments</span> <span class=o>=</span> <span class=n>colorAttachments</span><span class=p>.</span><span class=n>data</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>renderingInfo</span><span class=p>.</span><span class=n>pDepthAttachment</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>depthAttachment</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>renderingInfo</span><span class=p>.</span><span class=n>pStencilAttachment</span> <span class=o>=</span> <span class=n>VK_NULL_HANDLE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Start dynamic rendering
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>vkCmdBeginRenderingKHR</span><span class=p>(</span><span class=n>renderContext</span><span class=p>.</span><span class=n>getCurrentCommandBuffer</span><span class=p>(),</span> <span class=o>&amp;</span><span class=n>renderingInfo</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Draw the scene
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// End rendering
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>vkCmdEndRenderingKHR</span><span class=p>(</span><span class=n>renderContext</span><span class=p>.</span><span class=n>getCurrentCommandBuffer</span><span class=p>());</span>
</span></span></code></pre></td></tr></table></div></div><p>Looks simpler? It is.</p><h4 id=graphics-pipelines>Graphics Pipelines<a hidden class=anchor aria-hidden=true href=#graphics-pipelines>#</a></h4><p>Previously, pipeline objects required a pointer to a valid render pass. With dynamic rendering, you can simply set the <code>renderPass</code> field in <code>VkGraphicsPipelineCreateInfo</code> to <code>VK_NULL_HANDLE</code>. To support dynamic rendering, attach a <code>VkPipelineRenderingCreateInfoKHR</code> structure to the <code>pNext</code> field of <code>VkGraphicsPipelineCreateInfo</code>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>VkPipelineRenderingCreateInfoKHR</span> <span class=n>pipelineCreate</span><span class=p>{</span><span class=n>VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>pipelineCreate</span><span class=p>.</span><span class=n>pNext</span> <span class=o>=</span> <span class=n>VK_NULL_HANDLE</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>pipelineCreate</span><span class=p>.</span><span class=n>colorAttachmentCount</span> <span class=o>=</span> <span class=n>colorAttachmentFormats</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>pipelineCreate</span><span class=p>.</span><span class=n>pColorAttachmentFormats</span> <span class=o>=</span> <span class=n>colorAttachmentFormats</span><span class=p>.</span><span class=n>data</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>pipelineCreate</span><span class=p>.</span><span class=n>depthAttachmentFormat</span> <span class=o>=</span> <span class=n>depthFormat</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>pipelineCreate</span><span class=p>.</span><span class=n>stencilAttachmentFormat</span> <span class=o>=</span> <span class=n>depthFormat</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Use pNext to reference the pipelineCreate structure
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>VkGraphicsPipelineCreateInfo</span> <span class=n>graphicsCreate</span><span class=p>{</span><span class=n>VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>graphicsCreate</span><span class=p>.</span><span class=n>pNext</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>pipelineCreate</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>graphicsCreate</span><span class=p>.</span><span class=n>renderPass</span> <span class=o>=</span> <span class=n>VK_NULL_HANDLE</span><span class=p>;</span> <span class=c1>// Now optional
</span></span></span></code></pre></td></tr></table></div></div><p>And that’s it.</p><h2 id=benefits>Benefits<a hidden class=anchor aria-hidden=true href=#benefits>#</a></h2><p>Why use dynamic rendering? Here are some key advantages:</p><ol><li><p><strong>Simplified API</strong>: Render passes add hidden complexity by automatically transitioning images, which can be hard to trace. Dynamic rendering exposes transitions directly, offering more control to developers.</p></li><li><p><strong>Ease of Render Graph Implementation</strong>: Building a per-frame render graph (or frame graph) is challenging with static render passes and framebuffers. Dynamic rendering eliminates the need for object pooling and pass matching, reducing the workload.</p></li><li><p><strong>Improved Resource Management</strong>: Managing <code>VkFramebuffer</code> and <code>VkRenderPass</code> objects is cumbersome, especially when render target lifespans are unpredictable. Dynamic rendering simplifies this process and reduces CPU overhead.</p></li><li><p><strong>Flexibility in Pipeline Design</strong>: With dynamic rendering, pipelines are no longer tied to specific render passes. This decoupling allows greater flexibility when designing and reusing pipelines across different rendering setups.</p></li><li><p><strong>Reduced Boilerplate Code</strong>: By removing the need for <code>VkRenderPass</code> and <code>VkFramebuffer</code> objects, dynamic rendering significantly reduces the amount of boilerplate code, making Vulkan applications easier to write and maintain.</p></li><li><p><strong>Simplified Attachment Management</strong>: Managing attachments is more intuitive with dynamic rendering. You can directly specify the attachments during rendering without needing to predefine them in a render pass.</p></li></ol><h2 id=performance-considerations>Performance Considerations<a hidden class=anchor aria-hidden=true href=#performance-considerations>#</a></h2><p>On desktop GPUs, performance differences between dynamic rendering and traditional render passes are negligible. While desktop GPUs can occasionally <a href=https://gpuopen.com/learn/vulkan-renderpasses/>benefit from additional information</a> provided by render passes, this is mostly relevant for mobile GPUs, where the driver optimizations are more pronounced.</p><p>Dynamic rendering is ideal when you don’t need the specific advantages of traditional render passes, providing a low-overhead, streamlined API for most applications.</p><h2 id=additional-reading>Additional Reading<a hidden class=anchor aria-hidden=true href=#additional-reading>#</a></h2><ul><li><a href=https://developer.nvidia.com/blog/vulkan-dos-donts/>Vulkan Do&rsquo;s and Don&rsquo;ts</a></li><li><a href=https://gpuopen.com/learn/rdna-performance-guide/>RDNA Performance Guide</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/c++/>C++</a></li><li><a href=http://localhost:1313/tags/vulkan/>Vulkan</a></li><li><a href=http://localhost:1313/tags/computer-graphics/>Computer-Graphics</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/projects/surfer/><span class=title>« Prev</span><br><span>VulkanSurfer - minimal window library for Vulkan</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>Matej Elias</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>