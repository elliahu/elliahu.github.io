[{"content":"I’ve always played video games a little differently. While most people are busy saving the world or fighting off enemies, I’m sitting there wondering, how do they make this look so good? Like, how do they turn a bunch of code into moss so realistic it makes you want to touch it? These questions didn’t just cross my mind—they took over my life.\nNow, as a software engineer, I’ve made it my mission to understand how computer graphics actually work. Shaders, rendering pipelines, real-time lighting—it’s like a giant puzzle, and I can’t resist taking it apart to see how it fits together. Honestly, building these systems is just as fun (if not more) than watching the final visuals on the screen.\nI’ll never forget the time I played Horizon Forbidden West on the PS5. While everyone else was raving about the story and gameplay, I was staring at a patch of moss. One patch of moss. For an hour. I mean, the texture, the lighting, the tiny imperfections—chef’s kiss. That moss made me realize just how much I love the mix of art and engineering behind computer graphics.\nIt’s not just about games, either. From virtual reality to scientific simulations, I’m fascinated by how graphics shape our digital worlds. Whether I’m geeking out over shaders or brainstorming new ways to render something cool, I’m all in. It’s not just work; it’s what keeps me curious—and occasionally makes me weirdly emotional about moss.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’ve always played video games a little differently. While most people are busy saving the world or fighting off enemies, I’m sitting there wondering, how do they make this look so good? Like, how do they turn a bunch of code into moss so realistic it makes you want to touch it? These questions didn’t just cross my mind—they took over my life.\u003c/p\u003e\n\u003cp\u003eNow, as a software engineer, I’ve made it my mission to understand how computer graphics actually work. Shaders, rendering pipelines, real-time lighting—it’s like a giant puzzle, and I can’t resist taking it apart to see how it fits together. Honestly, building these systems is just as fun (if not more) than watching the final visuals on the screen.\u003c/p\u003e","title":"About me"},{"content":"Custom real-time physically-based graphics engine using c++23 and Vulkan - the next generation graphics API.\nAbout this project I\u0026rsquo;ve always enjoyed playing video games, but not quite like everyone else. While most people are immersed in the gameplay, I’ve always been curious about what’s happening under the hood. How do these games keep looking better and better? How is it even possible to render such detailed worlds on everyday hardware? These questions have fascinated me for as long as I can remember.\nOnce, while playing Horizon Forbidden West on the PS5, I spent over an hour just staring at a patch of moss—completely captivated by how realistic it looked. That’s who I am: someone who’s endlessly intrigued by the technology powering the visuals.\nMy first real hands-on experience with computer graphics was during university. While the professor wasn’t exactly the most approachable person, I thoroughly enjoyed the lectures. What I love most about computer graphics is how theory and practice come together to create something tangible—something you can see and interact with.\nI started my graphics programming journey with OpenGL, learning the basics and building a strong foundation. At some point, for no particular reason other than that it sounded cool, I decided to dive into Vulkan. Many years (and countless challenges) later, here I am, working on a Vulkan-based graphics engine. It’s been a long road filled with sweat, tears, and plenty of late nights, but I’m proud of what I’ve accomplished so far.\nThe project is still a work in progress—there are parts of the code that need serious rewrites—but every day it gets better. And to me, that’s the exciting part: the process of creating, learning, and improving.\nYou can find the source code and more information in the official repository.\nScreenshots Here you can screenshots from some of my rendering endeavors using the Hammock. ","permalink":"http://localhost:1313/projects/hammock/","summary":"\u003cp\u003eCustom real-time physically-based graphics engine using c++23 and Vulkan - the next generation graphics API.\u003c/p\u003e\n\u003ch2 id=\"about-this-project\"\u003eAbout this project\u003c/h2\u003e\n\u003cp\u003eI\u0026rsquo;ve always enjoyed playing video games, but not quite like everyone else. While most people are immersed in the gameplay, I’ve always been curious about what’s happening under the hood. How do these games keep looking better and better? How is it even possible to render such detailed worlds on everyday hardware? These questions have fascinated me for as long as I can remember.\u003c/p\u003e","title":"Hammock - Vulkan graphics engine"},{"content":"About this project In graphics engines and renderers, window management and event handling is often a necessary but tedious task. Most developers choose to abstract this functionality using libraries like GLFW, SDL, or similar tools. While these libraries are robust and feature-rich, they tend to be heavyweight and require installation via NuGet, vcpkg, or manual downloads. This can impact the portability of projects that rely on them.\nAs a researcher and graphics programming enthusiast, my needs are simpler. I primarily need a window for the rendering surface and basic input handling—just enough to close the window with the Esc key or enable basic camera movement. For such straightforward requirements, using a large library often feels like overkill. Don’t get me wrong—SDL2 is excellent, and GLFW is truly amazing. But for smaller projects, their size and complexity can be unnecessary.\nWhen I looked for lightweight, single-header alternatives, I was surprised to find a lack of options tailored to Vulkan. The OpenGL ecosystem has plenty of solutions, but Vulkan seems to have been overlooked in this area. That’s why I decided to create my own solution.\nWhat started as a utility extracted from my renderer has evolved into a portable, single-header window library designed specifically for Vulkan. It’s simple, lightweight, and focuses on exactly what’s needed—nothing more, nothing less.\nThis project aims to make creation of a window with a Vulkan surface and basic event handling as simple and portable as possible. If you just need a window with Vulkan surface and basic event handling, this is the tool you need. Library is header-only single file and there is no need for implementation files. Just drop it into you project.\nSimple API The window API was made so it is as simple as possible. Open a window and create a VkSurface in just two lines:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #define SURFER_PLATFORM_X11 #include \u0026#34;VulkanSurfer.h\u0026#34; // Create a window Surfer::Window * window = Surfer::Window::createWindow(\u0026#34;Example window\u0026#34;, instance, 800, 600 , 100, 100 ); // Get the surface VkSurfaceKHR surface = window-\u0026gt;getSurface(); // Draw while (!window-\u0026gt;shouldClose()) { // poll for events window-\u0026gt;pollEvents(); // do your rendering } // Don\u0026#39;t forget to destroy the window Surfer::Window::destroyWindow(window); See the full example here.\nCallback-based event handling Event handling is done using simple callback system.\n1 2 3 window-\u0026gt;registerKeyPressCallback([](Surfer::KeyCode key) { std::cout \u0026lt;\u0026lt; \u0026#34;Key pressed \u0026#34; \u0026lt;\u0026lt; static_cast\u0026lt;unsigned int\u0026gt;(key) \u0026lt;\u0026lt; std::endl; }); You can find the source code in the official repository.\n","permalink":"http://localhost:1313/projects/surfer/","summary":"\u003ch2 id=\"about-this-project\"\u003eAbout this project\u003c/h2\u003e\n\u003cp\u003eIn graphics engines and renderers, window management and event handling is often a necessary but tedious task. Most developers choose to abstract this functionality using libraries like GLFW, SDL, or similar tools. While these libraries are robust and feature-rich, they tend to be heavyweight and require installation via NuGet, vcpkg, or manual downloads. This can impact the portability of projects that rely on them.\u003c/p\u003e\n\u003cp\u003eAs a researcher and graphics programming enthusiast, my needs are simpler. I primarily need a window for the rendering surface and basic input handling—just enough to close the window with the Esc key or enable basic camera movement. For such straightforward requirements, using a large library often feels like overkill. Don’t get me wrong—SDL2 is excellent, and GLFW is truly amazing. But for smaller projects, their size and complexity can be unnecessary.\u003c/p\u003e","title":"VulkanSurfer - minimal window library for Vulkan"}]