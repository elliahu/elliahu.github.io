[{"content":"I’ve always approached video games a little differently than most. While others get caught up in the gameplay, I’ve always been drawn to what’s happening behind the scenes. How do these stunning visuals keep pushing boundaries year after year? How is it possible to render such detailed, lifelike worlds on everyday hardware? These questions didn’t just pique my curiosity—they shaped my career.\nAs a software engineer, I’ve channeled this fascination into understanding the technology that powers computer graphics. From shaders and rendering pipelines to real-time lighting and optimization, I’m passionate about breaking down how it all works and building systems that bring these concepts to life. For me, the process of creating visuals is as exciting as seeing the finished result on the screen.\nI still remember playing Horizon Forbidden West on the PS5 and being completely mesmerized—not by the action-packed gameplay, but by a simple patch of moss. I spent over an hour studying its texture, lighting, and tiny imperfections, captivated by how convincingly real it looked. That moment crystallized what drives me: a deep appreciation for the artistry and engineering behind computer graphics.\nMy curiosity doesn’t stop at games. Whether it’s architectural visualization, virtual reality, or scientific simulations, I’m inspired by how computer graphics blend creativity and technology to shape the way we see and interact with digital worlds. As both a software engineer and a graphics enthusiast, I’m committed to pushing the boundaries of what’s possible and contributing to the incredible visual experiences that define our era.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’ve always approached video games a little differently than most. While others get caught up in the gameplay, I’ve always been drawn to what’s happening behind the scenes. How do these stunning visuals keep pushing boundaries year after year? How is it possible to render such detailed, lifelike worlds on everyday hardware? These questions didn’t just pique my curiosity—they shaped my career.\u003c/p\u003e\n\u003cp\u003eAs a software engineer, I’ve channeled this fascination into understanding the technology that powers computer graphics. From shaders and rendering pipelines to real-time lighting and optimization, I’m passionate about breaking down how it all works and building systems that bring these concepts to life. For me, the process of creating visuals is as exciting as seeing the finished result on the screen.\u003c/p\u003e","title":"About me"},{"content":"Custom real-time physically-based graphics engine using c++23 and Vulkan - the next generation graphics API.\nAbout this project I\u0026rsquo;ve always enjoyed playing video games, but not quite like everyone else. While most people are immersed in the gameplay, I’ve always been curious about what’s happening under the hood. How do these games keep looking better and better? How is it even possible to render such detailed worlds on everyday hardware? These questions have fascinated me for as long as I can remember.\nOnce, while playing Horizon Forbidden West on the PS5, I spent over an hour just staring at a patch of moss—completely captivated by how realistic it looked. That’s who I am: someone who’s endlessly intrigued by the technology powering the visuals.\nMy first real hands-on experience with computer graphics was during university. While the professor wasn’t exactly the most approachable person, I thoroughly enjoyed the lectures. What I love most about computer graphics is how theory and practice come together to create something tangible—something you can see and interact with.\nI started my graphics programming journey with OpenGL, learning the basics and building a strong foundation. At some point, for no particular reason other than that it sounded cool, I decided to dive into Vulkan. Many years (and countless challenges) later, here I am, working on a Vulkan-based graphics engine. It’s been a long road filled with sweat, tears, and plenty of late nights, but I’m proud of what I’ve accomplished so far.\nThe project is still a work in progress—there are parts of the code that need serious rewrites—but every day it gets better. And to me, that’s the exciting part: the process of creating, learning, and improving.\nYou can find the source code and more information in the official repository.\nScreenshots Here you can screenshots from some of my rendering endeavors using the Hammock. ","permalink":"http://localhost:1313/projects/hammock/","summary":"\u003cp\u003eCustom real-time physically-based graphics engine using c++23 and Vulkan - the next generation graphics API.\u003c/p\u003e\n\u003ch2 id=\"about-this-project\"\u003eAbout this project\u003c/h2\u003e\n\u003cp\u003eI\u0026rsquo;ve always enjoyed playing video games, but not quite like everyone else. While most people are immersed in the gameplay, I’ve always been curious about what’s happening under the hood. How do these games keep looking better and better? How is it even possible to render such detailed worlds on everyday hardware? These questions have fascinated me for as long as I can remember.\u003c/p\u003e","title":"Hammock - Vulkan graphics engine"},{"content":"This project aims to make creation of a window with a Vulkan surface and basic event handling as simple and portable as possible. If you just need to open a simple window with basing event/input handling for your Vulkan projects, this is the tool you need. Library is header-only single file and there is no need for implementation files. Just drop it into you project.\nSimple API The window API was made so it is as simple as possible. Open a window and create a VkSurface in just two lines:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #define SURFER_PLATFORM_X11 #include \u0026#34;VulkanSurfer.h\u0026#34; // Create a window Surfer::Window * window = Surfer::Window::createWindow(\u0026#34;Example window\u0026#34;, instance, 800, 600 , 100, 100 ); // Get the surface VkSurfaceKHR surface = window-\u0026gt;getSurface(); // Draw while (!window-\u0026gt;shouldClose()) { // poll for events window-\u0026gt;pollEvents(); // do your rendering } // Don\u0026#39;t forget to destroy the window Surfer::Window::destroyWindow(window); See the full example here.\nCallback-based event handling Event handling is done using simple callback system.\n1 2 3 window-\u0026gt;registerKeyPressCallback([](Surfer::KeyCode key) { std::cout \u0026lt;\u0026lt; \u0026#34;Key pressed \u0026#34; \u0026lt;\u0026lt; static_cast\u0026lt;unsigned int\u0026gt;(key) \u0026lt;\u0026lt; std::endl; }); About this project In graphics engines and renderers, window management and event handling is often a necessary but tedious task. Most developers choose to abstract this functionality using libraries like GLFW, SDL, or similar tools. While these libraries are robust and feature-rich, they tend to be heavyweight and require installation via NuGet, vcpkg, or manual downloads. This can impact the portability of projects that rely on them.\nAs a researcher and graphics programming enthusiast, my needs are simpler. I primarily need a window for the rendering surface and basic input handling—just enough to close the window with the Esc key or enable basic camera movement. For such straightforward requirements, using a large library often feels like overkill. Don’t get me wrong—SDL2 is excellent, and GLFW is truly amazing. But for smaller projects, their size and complexity can be unnecessary.\nWhen I looked for lightweight, single-header alternatives, I was surprised to find a lack of options tailored to Vulkan. The OpenGL ecosystem has plenty of solutions, but Vulkan seems to have been overlooked in this area. That’s why I decided to create my own solution.\nWhat started as a utility extracted from my renderer has evolved into a portable, single-header window library designed specifically for Vulkan. It’s simple, lightweight, and focuses on exactly what’s needed—nothing more, nothing less.\nYou can find the source code in the official repository.\n","permalink":"http://localhost:1313/projects/surfer/","summary":"\u003cp\u003eThis \u003ca href=\"https://github.com/elliahu/VulkanSurfer\"\u003eproject\u003c/a\u003e aims to make creation of a window with a Vulkan surface and basic event handling as simple and portable as possible. If you just need to open a simple window with basing event/input handling for your Vulkan projects, this is the tool you need. Library is header-only single file and there is no need for implementation files. Just drop it into you project.\u003c/p\u003e\n\u003ch2 id=\"simple-api\"\u003eSimple API\u003c/h2\u003e\n\u003cp\u003eThe window API was made so it is as simple as possible. Open a window and create a VkSurface in just two lines:\u003c/p\u003e","title":"VulkanSurfer - minimal window library for Vulkan"},{"content":"I’ve always approached video games a little differently than most. While others get caught up in the gameplay, I’ve always been drawn to what’s happening behind the scenes. How do these stunning visuals keep pushing boundaries year after year? How is it possible to render such detailed, lifelike worlds on everyday hardware? These questions didn’t just pique my curiosity—they shaped my career.\nAs a software engineer, I’ve channeled this fascination into understanding the technology that powers computer graphics. From shaders and rendering pipelines to real-time lighting and optimization, I’m passionate about breaking down how it all works and building systems that bring these concepts to life. For me, the process of creating visuals is as exciting as seeing the finished result on the screen.\nI still remember playing Horizon Forbidden West on the PS5 and being completely mesmerized—not by the action-packed gameplay, but by a simple patch of moss. I spent over an hour studying its texture, lighting, and tiny imperfections, captivated by how convincingly real it looked. That moment crystallized what drives me: a deep appreciation for the artistry and engineering behind computer graphics.\nMy curiosity doesn’t stop at games. Whether it’s architectural visualization, virtual reality, or scientific simulations, I’m inspired by how computer graphics blend creativity and technology to shape the way we see and interact with digital worlds. As both a software engineer and a graphics enthusiast, I’m committed to pushing the boundaries of what’s possible and contributing to the incredible visual experiences that define our era.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’ve always approached video games a little differently than most. While others get caught up in the gameplay, I’ve always been drawn to what’s happening behind the scenes. How do these stunning visuals keep pushing boundaries year after year? How is it possible to render such detailed, lifelike worlds on everyday hardware? These questions didn’t just pique my curiosity—they shaped my career.\u003c/p\u003e\n\u003cp\u003eAs a software engineer, I’ve channeled this fascination into understanding the technology that powers computer graphics. From shaders and rendering pipelines to real-time lighting and optimization, I’m passionate about breaking down how it all works and building systems that bring these concepts to life. For me, the process of creating visuals is as exciting as seeing the finished result on the screen.\u003c/p\u003e","title":"About me"},{"content":"Custom real-time physically-based graphics engine using c++23 and Vulkan - the next generation graphics API.\nAbout this project I\u0026rsquo;ve always enjoyed playing video games, but not quite like everyone else. While most people are immersed in the gameplay, I’ve always been curious about what’s happening under the hood. How do these games keep looking better and better? How is it even possible to render such detailed worlds on everyday hardware? These questions have fascinated me for as long as I can remember.\nOnce, while playing Horizon Forbidden West on the PS5, I spent over an hour just staring at a patch of moss—completely captivated by how realistic it looked. That’s who I am: someone who’s endlessly intrigued by the technology powering the visuals.\nMy first real hands-on experience with computer graphics was during university. While the professor wasn’t exactly the most approachable person, I thoroughly enjoyed the lectures. What I love most about computer graphics is how theory and practice come together to create something tangible—something you can see and interact with.\nI started my graphics programming journey with OpenGL, learning the basics and building a strong foundation. At some point, for no particular reason other than that it sounded cool, I decided to dive into Vulkan. Many years (and countless challenges) later, here I am, working on a Vulkan-based graphics engine. It’s been a long road filled with sweat, tears, and plenty of late nights, but I’m proud of what I’ve accomplished so far.\nThe project is still a work in progress—there are parts of the code that need serious rewrites—but every day it gets better. And to me, that’s the exciting part: the process of creating, learning, and improving.\nYou can find the source code and more information in the official repository.\nScreenshots Here you can screenshots from some of my rendering endeavors using the Hammock. ","permalink":"http://localhost:1313/projects/hammock/","summary":"\u003cp\u003eCustom real-time physically-based graphics engine using c++23 and Vulkan - the next generation graphics API.\u003c/p\u003e\n\u003ch2 id=\"about-this-project\"\u003eAbout this project\u003c/h2\u003e\n\u003cp\u003eI\u0026rsquo;ve always enjoyed playing video games, but not quite like everyone else. While most people are immersed in the gameplay, I’ve always been curious about what’s happening under the hood. How do these games keep looking better and better? How is it even possible to render such detailed worlds on everyday hardware? These questions have fascinated me for as long as I can remember.\u003c/p\u003e","title":"Hammock - Vulkan graphics engine"},{"content":"This project aims to make creation of a window with a Vulkan surface and basic event handling as simple and portable as possible. If you just need to open a simple window with basing event/input handling for your Vulkan projects, this is the tool you need. Library is header-only single file and there is no need for implementation files. Just drop it into you project.\nSimple API The window API was made so it is as simple as possible. Open a window and create a VkSurface in just two lines:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #define SURFER_PLATFORM_X11 #include \u0026#34;VulkanSurfer.h\u0026#34; // Create a window Surfer::Window * window = Surfer::Window::createWindow(\u0026#34;Example window\u0026#34;, instance, 800, 600 , 100, 100 ); // Get the surface VkSurfaceKHR surface = window-\u0026gt;getSurface(); // Draw while (!window-\u0026gt;shouldClose()) { // poll for events window-\u0026gt;pollEvents(); // do your rendering } // Don\u0026#39;t forget to destroy the window Surfer::Window::destroyWindow(window); See the full example here.\nCallback-based event handling Event handling is done using simple callback system.\n1 2 3 window-\u0026gt;registerKeyPressCallback([](Surfer::KeyCode key) { std::cout \u0026lt;\u0026lt; \u0026#34;Key pressed \u0026#34; \u0026lt;\u0026lt; static_cast\u0026lt;unsigned int\u0026gt;(key) \u0026lt;\u0026lt; std::endl; }); About this project In graphics engines and renderers, window management and event handling is often a necessary but tedious task. Most developers choose to abstract this functionality using libraries like GLFW, SDL, or similar tools. While these libraries are robust and feature-rich, they tend to be heavyweight and require installation via NuGet, vcpkg, or manual downloads. This can impact the portability of projects that rely on them.\nAs a researcher and graphics programming enthusiast, my needs are simpler. I primarily need a window for the rendering surface and basic input handling—just enough to close the window with the Esc key or enable basic camera movement. For such straightforward requirements, using a large library often feels like overkill. Don’t get me wrong—SDL2 is excellent, and GLFW is truly amazing. But for smaller projects, their size and complexity can be unnecessary.\nWhen I looked for lightweight, single-header alternatives, I was surprised to find a lack of options tailored to Vulkan. The OpenGL ecosystem has plenty of solutions, but Vulkan seems to have been overlooked in this area. That’s why I decided to create my own solution.\nWhat started as a utility extracted from my renderer has evolved into a portable, single-header window library designed specifically for Vulkan. It’s simple, lightweight, and focuses on exactly what’s needed—nothing more, nothing less.\nYou can find the source code in the official repository.\n","permalink":"http://localhost:1313/projects/surfer/","summary":"\u003cp\u003eThis \u003ca href=\"https://github.com/elliahu/VulkanSurfer\"\u003eproject\u003c/a\u003e aims to make creation of a window with a Vulkan surface and basic event handling as simple and portable as possible. If you just need to open a simple window with basing event/input handling for your Vulkan projects, this is the tool you need. Library is header-only single file and there is no need for implementation files. Just drop it into you project.\u003c/p\u003e\n\u003ch2 id=\"simple-api\"\u003eSimple API\u003c/h2\u003e\n\u003cp\u003eThe window API was made so it is as simple as possible. Open a window and create a VkSurface in just two lines:\u003c/p\u003e","title":"VulkanSurfer - minimal window library for Vulkan"},{"content":"I’ve always approached video games a little differently than most. While others get caught up in the gameplay, I’ve always been drawn to what’s happening behind the scenes. How do these stunning visuals keep pushing boundaries year after year? How is it possible to render such detailed, lifelike worlds on everyday hardware? These questions didn’t just pique my curiosity—they shaped my career.\nAs a software engineer, I’ve channeled this fascination into understanding the technology that powers computer graphics. From shaders and rendering pipelines to real-time lighting and optimization, I’m passionate about breaking down how it all works and building systems that bring these concepts to life. For me, the process of creating visuals is as exciting as seeing the finished result on the screen.\nI still remember playing Horizon Forbidden West on the PS5 and being completely mesmerized—not by the action-packed gameplay, but by a simple patch of moss. I spent over an hour studying its texture, lighting, and tiny imperfections, captivated by how convincingly real it looked. That moment crystallized what drives me: a deep appreciation for the artistry and engineering behind computer graphics.\nMy curiosity doesn’t stop at games. Whether it’s architectural visualization, virtual reality, or scientific simulations, I’m inspired by how computer graphics blend creativity and technology to shape the way we see and interact with digital worlds. As both a software engineer and a graphics enthusiast, I’m committed to pushing the boundaries of what’s possible and contributing to the incredible visual experiences that define our era.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’ve always approached video games a little differently than most. While others get caught up in the gameplay, I’ve always been drawn to what’s happening behind the scenes. How do these stunning visuals keep pushing boundaries year after year? How is it possible to render such detailed, lifelike worlds on everyday hardware? These questions didn’t just pique my curiosity—they shaped my career.\u003c/p\u003e\n\u003cp\u003eAs a software engineer, I’ve channeled this fascination into understanding the technology that powers computer graphics. From shaders and rendering pipelines to real-time lighting and optimization, I’m passionate about breaking down how it all works and building systems that bring these concepts to life. For me, the process of creating visuals is as exciting as seeing the finished result on the screen.\u003c/p\u003e","title":"About me"},{"content":"Custom real-time physically-based graphics engine using c++23 and Vulkan - the next generation graphics API.\nAbout this project I\u0026rsquo;ve always enjoyed playing video games, but not quite like everyone else. While most people are immersed in the gameplay, I’ve always been curious about what’s happening under the hood. How do these games keep looking better and better? How is it even possible to render such detailed worlds on everyday hardware? These questions have fascinated me for as long as I can remember.\nOnce, while playing Horizon Forbidden West on the PS5, I spent over an hour just staring at a patch of moss—completely captivated by how realistic it looked. That’s who I am: someone who’s endlessly intrigued by the technology powering the visuals.\nMy first real hands-on experience with computer graphics was during university. While the professor wasn’t exactly the most approachable person, I thoroughly enjoyed the lectures. What I love most about computer graphics is how theory and practice come together to create something tangible—something you can see and interact with.\nI started my graphics programming journey with OpenGL, learning the basics and building a strong foundation. At some point, for no particular reason other than that it sounded cool, I decided to dive into Vulkan. Many years (and countless challenges) later, here I am, working on a Vulkan-based graphics engine. It’s been a long road filled with sweat, tears, and plenty of late nights, but I’m proud of what I’ve accomplished so far.\nThe project is still a work in progress—there are parts of the code that need serious rewrites—but every day it gets better. And to me, that’s the exciting part: the process of creating, learning, and improving.\nYou can find the source code and more information in the official repository.\nScreenshots Here you can screenshots from some of my rendering endeavors using the Hammock. ","permalink":"http://localhost:1313/projects/hammock/","summary":"\u003cp\u003eCustom real-time physically-based graphics engine using c++23 and Vulkan - the next generation graphics API.\u003c/p\u003e\n\u003ch2 id=\"about-this-project\"\u003eAbout this project\u003c/h2\u003e\n\u003cp\u003eI\u0026rsquo;ve always enjoyed playing video games, but not quite like everyone else. While most people are immersed in the gameplay, I’ve always been curious about what’s happening under the hood. How do these games keep looking better and better? How is it even possible to render such detailed worlds on everyday hardware? These questions have fascinated me for as long as I can remember.\u003c/p\u003e","title":"Hammock - Vulkan graphics engine"},{"content":"This project aims to make creation of a window with a Vulkan surface and basic event handling as simple and portable as possible. If you just need to open a simple window with basing event/input handling for your Vulkan projects, this is the tool you need. Library is header-only single file and there is no need for implementation files. Just drop it into you project.\nSimple API The window API was made so it is as simple as possible. Open a window and create a VkSurface in just two lines:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #define SURFER_PLATFORM_X11 #include \u0026#34;VulkanSurfer.h\u0026#34; // Create a window Surfer::Window * window = Surfer::Window::createWindow(\u0026#34;Example window\u0026#34;, instance, 800, 600 , 100, 100 ); // Get the surface VkSurfaceKHR surface = window-\u0026gt;getSurface(); // Draw while (!window-\u0026gt;shouldClose()) { // poll for events window-\u0026gt;pollEvents(); // do your rendering } // Don\u0026#39;t forget to destroy the window Surfer::Window::destroyWindow(window); See the full example here.\nCallback-based event handling Event handling is done using simple callback system.\n1 2 3 window-\u0026gt;registerKeyPressCallback([](Surfer::KeyCode key) { std::cout \u0026lt;\u0026lt; \u0026#34;Key pressed \u0026#34; \u0026lt;\u0026lt; static_cast\u0026lt;unsigned int\u0026gt;(key) \u0026lt;\u0026lt; std::endl; }); About this project In graphics engines and renderers, window management and event handling is often a necessary but tedious task. Most developers choose to abstract this functionality using libraries like GLFW, SDL, or similar tools. While these libraries are robust and feature-rich, they tend to be heavyweight and require installation via NuGet, vcpkg, or manual downloads. This can impact the portability of projects that rely on them.\nAs a researcher and graphics programming enthusiast, my needs are simpler. I primarily need a window for the rendering surface and basic input handling—just enough to close the window with the Esc key or enable basic camera movement. For such straightforward requirements, using a large library often feels like overkill. Don’t get me wrong—SDL2 is excellent, and GLFW is truly amazing. But for smaller projects, their size and complexity can be unnecessary.\nWhen I looked for lightweight, single-header alternatives, I was surprised to find a lack of options tailored to Vulkan. The OpenGL ecosystem has plenty of solutions, but Vulkan seems to have been overlooked in this area. That’s why I decided to create my own solution.\nWhat started as a utility extracted from my renderer has evolved into a portable, single-header window library designed specifically for Vulkan. It’s simple, lightweight, and focuses on exactly what’s needed—nothing more, nothing less.\nYou can find the source code in the official repository.\n","permalink":"http://localhost:1313/projects/surfer/","summary":"\u003cp\u003eThis \u003ca href=\"https://github.com/elliahu/VulkanSurfer\"\u003eproject\u003c/a\u003e aims to make creation of a window with a Vulkan surface and basic event handling as simple and portable as possible. If you just need to open a simple window with basing event/input handling for your Vulkan projects, this is the tool you need. Library is header-only single file and there is no need for implementation files. Just drop it into you project.\u003c/p\u003e\n\u003ch2 id=\"simple-api\"\u003eSimple API\u003c/h2\u003e\n\u003cp\u003eThe window API was made so it is as simple as possible. Open a window and create a VkSurface in just two lines:\u003c/p\u003e","title":"VulkanSurfer - minimal window library for Vulkan"},{"content":"I’ve always approached video games a little differently than most. While others get caught up in the gameplay, I’ve always been drawn to what’s happening behind the scenes. How do these stunning visuals keep pushing boundaries year after year? How is it possible to render such detailed, lifelike worlds on everyday hardware? These questions didn’t just pique my curiosity—they shaped my career.\nAs a software engineer, I’ve channeled this fascination into understanding the technology that powers computer graphics. From shaders and rendering pipelines to real-time lighting and optimization, I’m passionate about breaking down how it all works and building systems that bring these concepts to life. For me, the process of creating visuals is as exciting as seeing the finished result on the screen.\nI still remember playing Horizon Forbidden West on the PS5 and being completely mesmerized—not by the action-packed gameplay, but by a simple patch of moss. I spent over an hour studying its texture, lighting, and tiny imperfections, captivated by how convincingly real it looked. That moment crystallized what drives me: a deep appreciation for the artistry and engineering behind computer graphics.\nMy curiosity doesn’t stop at games. Whether it’s architectural visualization, virtual reality, or scientific simulations, I’m inspired by how computer graphics blend creativity and technology to shape the way we see and interact with digital worlds. As both a software engineer and a graphics enthusiast, I’m committed to pushing the boundaries of what’s possible and contributing to the incredible visual experiences that define our era.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’ve always approached video games a little differently than most. While others get caught up in the gameplay, I’ve always been drawn to what’s happening behind the scenes. How do these stunning visuals keep pushing boundaries year after year? How is it possible to render such detailed, lifelike worlds on everyday hardware? These questions didn’t just pique my curiosity—they shaped my career.\u003c/p\u003e\n\u003cp\u003eAs a software engineer, I’ve channeled this fascination into understanding the technology that powers computer graphics. From shaders and rendering pipelines to real-time lighting and optimization, I’m passionate about breaking down how it all works and building systems that bring these concepts to life. For me, the process of creating visuals is as exciting as seeing the finished result on the screen.\u003c/p\u003e","title":"About me"},{"content":"Custom real-time physically-based graphics engine using c++23 and Vulkan - the next generation graphics API.\nAbout this project I\u0026rsquo;ve always enjoyed playing video games, but not quite like everyone else. While most people are immersed in the gameplay, I’ve always been curious about what’s happening under the hood. How do these games keep looking better and better? How is it even possible to render such detailed worlds on everyday hardware? These questions have fascinated me for as long as I can remember.\nOnce, while playing Horizon Forbidden West on the PS5, I spent over an hour just staring at a patch of moss—completely captivated by how realistic it looked. That’s who I am: someone who’s endlessly intrigued by the technology powering the visuals.\nMy first real hands-on experience with computer graphics was during university. While the professor wasn’t exactly the most approachable person, I thoroughly enjoyed the lectures. What I love most about computer graphics is how theory and practice come together to create something tangible—something you can see and interact with.\nI started my graphics programming journey with OpenGL, learning the basics and building a strong foundation. At some point, for no particular reason other than that it sounded cool, I decided to dive into Vulkan. Many years (and countless challenges) later, here I am, working on a Vulkan-based graphics engine. It’s been a long road filled with sweat, tears, and plenty of late nights, but I’m proud of what I’ve accomplished so far.\nThe project is still a work in progress—there are parts of the code that need serious rewrites—but every day it gets better. And to me, that’s the exciting part: the process of creating, learning, and improving.\nYou can find the source code and more information in the official repository.\nScreenshots Here you can screenshots from some of my rendering endeavors using the Hammock. ","permalink":"http://localhost:1313/projects/hammock/","summary":"\u003cp\u003eCustom real-time physically-based graphics engine using c++23 and Vulkan - the next generation graphics API.\u003c/p\u003e\n\u003ch2 id=\"about-this-project\"\u003eAbout this project\u003c/h2\u003e\n\u003cp\u003eI\u0026rsquo;ve always enjoyed playing video games, but not quite like everyone else. While most people are immersed in the gameplay, I’ve always been curious about what’s happening under the hood. How do these games keep looking better and better? How is it even possible to render such detailed worlds on everyday hardware? These questions have fascinated me for as long as I can remember.\u003c/p\u003e","title":"Hammock - Vulkan graphics engine"},{"content":"This project aims to make creation of a window with a Vulkan surface and basic event handling as simple and portable as possible. If you just need to open a simple window with basing event/input handling for your Vulkan projects, this is the tool you need. Library is header-only single file and there is no need for implementation files. Just drop it into you project.\nSimple API The window API was made so it is as simple as possible. Open a window and create a VkSurface in just two lines:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #define SURFER_PLATFORM_X11 #include \u0026#34;VulkanSurfer.h\u0026#34; // Create a window Surfer::Window * window = Surfer::Window::createWindow(\u0026#34;Example window\u0026#34;, instance, 800, 600 , 100, 100 ); // Get the surface VkSurfaceKHR surface = window-\u0026gt;getSurface(); // Draw while (!window-\u0026gt;shouldClose()) { // poll for events window-\u0026gt;pollEvents(); // do your rendering } // Don\u0026#39;t forget to destroy the window Surfer::Window::destroyWindow(window); See the full example here.\nCallback-based event handling Event handling is done using simple callback system.\n1 2 3 window-\u0026gt;registerKeyPressCallback([](Surfer::KeyCode key) { std::cout \u0026lt;\u0026lt; \u0026#34;Key pressed \u0026#34; \u0026lt;\u0026lt; static_cast\u0026lt;unsigned int\u0026gt;(key) \u0026lt;\u0026lt; std::endl; }); About this project In graphics engines and renderers, window management and event handling is often a necessary but tedious task. Most developers choose to abstract this functionality using libraries like GLFW, SDL, or similar tools. While these libraries are robust and feature-rich, they tend to be heavyweight and require installation via NuGet, vcpkg, or manual downloads. This can impact the portability of projects that rely on them.\nAs a researcher and graphics programming enthusiast, my needs are simpler. I primarily need a window for the rendering surface and basic input handling—just enough to close the window with the Esc key or enable basic camera movement. For such straightforward requirements, using a large library often feels like overkill. Don’t get me wrong—SDL2 is excellent, and GLFW is truly amazing. But for smaller projects, their size and complexity can be unnecessary.\nWhen I looked for lightweight, single-header alternatives, I was surprised to find a lack of options tailored to Vulkan. The OpenGL ecosystem has plenty of solutions, but Vulkan seems to have been overlooked in this area. That’s why I decided to create my own solution.\nWhat started as a utility extracted from my renderer has evolved into a portable, single-header window library designed specifically for Vulkan. It’s simple, lightweight, and focuses on exactly what’s needed—nothing more, nothing less.\nYou can find the source code in the official repository.\n","permalink":"http://localhost:1313/projects/surfer/","summary":"\u003cp\u003eThis \u003ca href=\"https://github.com/elliahu/VulkanSurfer\"\u003eproject\u003c/a\u003e aims to make creation of a window with a Vulkan surface and basic event handling as simple and portable as possible. If you just need to open a simple window with basing event/input handling for your Vulkan projects, this is the tool you need. Library is header-only single file and there is no need for implementation files. Just drop it into you project.\u003c/p\u003e\n\u003ch2 id=\"simple-api\"\u003eSimple API\u003c/h2\u003e\n\u003cp\u003eThe window API was made so it is as simple as possible. Open a window and create a VkSurface in just two lines:\u003c/p\u003e","title":"VulkanSurfer - minimal window library for Vulkan"},{"content":"I’ve always approached video games a little differently than most. While others get caught up in the gameplay, I’ve always been drawn to what’s happening behind the scenes. How do these stunning visuals keep pushing boundaries year after year? How is it possible to render such detailed, lifelike worlds on everyday hardware? These questions didn’t just pique my curiosity—they shaped my career.\nAs a software engineer, I’ve channeled this fascination into understanding the technology that powers computer graphics. From shaders and rendering pipelines to real-time lighting and optimization, I’m passionate about breaking down how it all works and building systems that bring these concepts to life. For me, the process of creating visuals is as exciting as seeing the finished result on the screen.\nI still remember playing Horizon Forbidden West on the PS5 and being completely mesmerized—not by the action-packed gameplay, but by a simple patch of moss. I spent over an hour studying its texture, lighting, and tiny imperfections, captivated by how convincingly real it looked. That moment crystallized what drives me: a deep appreciation for the artistry and engineering behind computer graphics.\nMy curiosity doesn’t stop at games. Whether it’s architectural visualization, virtual reality, or scientific simulations, I’m inspired by how computer graphics blend creativity and technology to shape the way we see and interact with digital worlds. As both a software engineer and a graphics enthusiast, I’m committed to pushing the boundaries of what’s possible and contributing to the incredible visual experiences that define our era.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’ve always approached video games a little differently than most. While others get caught up in the gameplay, I’ve always been drawn to what’s happening behind the scenes. How do these stunning visuals keep pushing boundaries year after year? How is it possible to render such detailed, lifelike worlds on everyday hardware? These questions didn’t just pique my curiosity—they shaped my career.\u003c/p\u003e\n\u003cp\u003eAs a software engineer, I’ve channeled this fascination into understanding the technology that powers computer graphics. From shaders and rendering pipelines to real-time lighting and optimization, I’m passionate about breaking down how it all works and building systems that bring these concepts to life. For me, the process of creating visuals is as exciting as seeing the finished result on the screen.\u003c/p\u003e","title":"About me"},{"content":"Custom real-time physically-based graphics engine using c++23 and Vulkan - the next generation graphics API.\nAbout this project I\u0026rsquo;ve always enjoyed playing video games, but not quite like everyone else. While most people are immersed in the gameplay, I’ve always been curious about what’s happening under the hood. How do these games keep looking better and better? How is it even possible to render such detailed worlds on everyday hardware? These questions have fascinated me for as long as I can remember.\nOnce, while playing Horizon Forbidden West on the PS5, I spent over an hour just staring at a patch of moss—completely captivated by how realistic it looked. That’s who I am: someone who’s endlessly intrigued by the technology powering the visuals.\nMy first real hands-on experience with computer graphics was during university. While the professor wasn’t exactly the most approachable person, I thoroughly enjoyed the lectures. What I love most about computer graphics is how theory and practice come together to create something tangible—something you can see and interact with.\nI started my graphics programming journey with OpenGL, learning the basics and building a strong foundation. At some point, for no particular reason other than that it sounded cool, I decided to dive into Vulkan. Many years (and countless challenges) later, here I am, working on a Vulkan-based graphics engine. It’s been a long road filled with sweat, tears, and plenty of late nights, but I’m proud of what I’ve accomplished so far.\nThe project is still a work in progress—there are parts of the code that need serious rewrites—but every day it gets better. And to me, that’s the exciting part: the process of creating, learning, and improving.\nYou can find the source code and more information in the official repository.\nScreenshots Here you can screenshots from some of my rendering endeavors using the Hammock. ","permalink":"http://localhost:1313/projects/hammock/","summary":"\u003cp\u003eCustom real-time physically-based graphics engine using c++23 and Vulkan - the next generation graphics API.\u003c/p\u003e\n\u003ch2 id=\"about-this-project\"\u003eAbout this project\u003c/h2\u003e\n\u003cp\u003eI\u0026rsquo;ve always enjoyed playing video games, but not quite like everyone else. While most people are immersed in the gameplay, I’ve always been curious about what’s happening under the hood. How do these games keep looking better and better? How is it even possible to render such detailed worlds on everyday hardware? These questions have fascinated me for as long as I can remember.\u003c/p\u003e","title":"Hammock - Vulkan graphics engine"},{"content":"This project aims to make creation of a window with a Vulkan surface and basic event handling as simple and portable as possible. If you just need to open a simple window with basing event/input handling for your Vulkan projects, this is the tool you need. Library is header-only single file and there is no need for implementation files. Just drop it into you project.\nSimple API The window API was made so it is as simple as possible. Open a window and create a VkSurface in just two lines:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #define SURFER_PLATFORM_X11 #include \u0026#34;VulkanSurfer.h\u0026#34; // Create a window Surfer::Window * window = Surfer::Window::createWindow(\u0026#34;Example window\u0026#34;, instance, 800, 600 , 100, 100 ); // Get the surface VkSurfaceKHR surface = window-\u0026gt;getSurface(); // Draw while (!window-\u0026gt;shouldClose()) { // poll for events window-\u0026gt;pollEvents(); // do your rendering } // Don\u0026#39;t forget to destroy the window Surfer::Window::destroyWindow(window); See the full example here.\nCallback-based event handling Event handling is done using simple callback system.\n1 2 3 window-\u0026gt;registerKeyPressCallback([](Surfer::KeyCode key) { std::cout \u0026lt;\u0026lt; \u0026#34;Key pressed \u0026#34; \u0026lt;\u0026lt; static_cast\u0026lt;unsigned int\u0026gt;(key) \u0026lt;\u0026lt; std::endl; }); About this project In graphics engines and renderers, window management and event handling is often a necessary but tedious task. Most developers choose to abstract this functionality using libraries like GLFW, SDL, or similar tools. While these libraries are robust and feature-rich, they tend to be heavyweight and require installation via NuGet, vcpkg, or manual downloads. This can impact the portability of projects that rely on them.\nAs a researcher and graphics programming enthusiast, my needs are simpler. I primarily need a window for the rendering surface and basic input handling—just enough to close the window with the Esc key or enable basic camera movement. For such straightforward requirements, using a large library often feels like overkill. Don’t get me wrong—SDL2 is excellent, and GLFW is truly amazing. But for smaller projects, their size and complexity can be unnecessary.\nWhen I looked for lightweight, single-header alternatives, I was surprised to find a lack of options tailored to Vulkan. The OpenGL ecosystem has plenty of solutions, but Vulkan seems to have been overlooked in this area. That’s why I decided to create my own solution.\nWhat started as a utility extracted from my renderer has evolved into a portable, single-header window library designed specifically for Vulkan. It’s simple, lightweight, and focuses on exactly what’s needed—nothing more, nothing less.\nYou can find the source code in the official repository.\n","permalink":"http://localhost:1313/projects/surfer/","summary":"\u003cp\u003eThis \u003ca href=\"https://github.com/elliahu/VulkanSurfer\"\u003eproject\u003c/a\u003e aims to make creation of a window with a Vulkan surface and basic event handling as simple and portable as possible. If you just need to open a simple window with basing event/input handling for your Vulkan projects, this is the tool you need. Library is header-only single file and there is no need for implementation files. Just drop it into you project.\u003c/p\u003e\n\u003ch2 id=\"simple-api\"\u003eSimple API\u003c/h2\u003e\n\u003cp\u003eThe window API was made so it is as simple as possible. Open a window and create a VkSurface in just two lines:\u003c/p\u003e","title":"VulkanSurfer - minimal window library for Vulkan"},{"content":"I’ve always approached video games a little differently than most. While others get caught up in the gameplay, I’ve always been drawn to what’s happening behind the scenes. How do these stunning visuals keep pushing boundaries year after year? How is it possible to render such detailed, lifelike worlds on everyday hardware? These questions didn’t just pique my curiosity—they shaped my career.\nAs a software engineer, I’ve channeled this fascination into understanding the technology that powers computer graphics. From shaders and rendering pipelines to real-time lighting and optimization, I’m passionate about breaking down how it all works and building systems that bring these concepts to life. For me, the process of creating visuals is as exciting as seeing the finished result on the screen.\nI still remember playing Horizon Forbidden West on the PS5 and being completely mesmerized—not by the action-packed gameplay, but by a simple patch of moss. I spent over an hour studying its texture, lighting, and tiny imperfections, captivated by how convincingly real it looked. That moment crystallized what drives me: a deep appreciation for the artistry and engineering behind computer graphics.\nMy curiosity doesn’t stop at games. Whether it’s architectural visualization, virtual reality, or scientific simulations, I’m inspired by how computer graphics blend creativity and technology to shape the way we see and interact with digital worlds. As both a software engineer and a graphics enthusiast, I’m committed to pushing the boundaries of what’s possible and contributing to the incredible visual experiences that define our era.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’ve always approached video games a little differently than most. While others get caught up in the gameplay, I’ve always been drawn to what’s happening behind the scenes. How do these stunning visuals keep pushing boundaries year after year? How is it possible to render such detailed, lifelike worlds on everyday hardware? These questions didn’t just pique my curiosity—they shaped my career.\u003c/p\u003e\n\u003cp\u003eAs a software engineer, I’ve channeled this fascination into understanding the technology that powers computer graphics. From shaders and rendering pipelines to real-time lighting and optimization, I’m passionate about breaking down how it all works and building systems that bring these concepts to life. For me, the process of creating visuals is as exciting as seeing the finished result on the screen.\u003c/p\u003e","title":"About me"},{"content":"Custom real-time physically-based graphics engine using c++23 and Vulkan - the next generation graphics API.\nAbout this project I\u0026rsquo;ve always enjoyed playing video games, but not quite like everyone else. While most people are immersed in the gameplay, I’ve always been curious about what’s happening under the hood. How do these games keep looking better and better? How is it even possible to render such detailed worlds on everyday hardware? These questions have fascinated me for as long as I can remember.\nOnce, while playing Horizon Forbidden West on the PS5, I spent over an hour just staring at a patch of moss—completely captivated by how realistic it looked. That’s who I am: someone who’s endlessly intrigued by the technology powering the visuals.\nMy first real hands-on experience with computer graphics was during university. While the professor wasn’t exactly the most approachable person, I thoroughly enjoyed the lectures. What I love most about computer graphics is how theory and practice come together to create something tangible—something you can see and interact with.\nI started my graphics programming journey with OpenGL, learning the basics and building a strong foundation. At some point, for no particular reason other than that it sounded cool, I decided to dive into Vulkan. Many years (and countless challenges) later, here I am, working on a Vulkan-based graphics engine. It’s been a long road filled with sweat, tears, and plenty of late nights, but I’m proud of what I’ve accomplished so far.\nThe project is still a work in progress—there are parts of the code that need serious rewrites—but every day it gets better. And to me, that’s the exciting part: the process of creating, learning, and improving.\nYou can find the source code and more information in the official repository.\nScreenshots Here you can screenshots from some of my rendering endeavors using the Hammock. ","permalink":"http://localhost:1313/projects/hammock/","summary":"\u003cp\u003eCustom real-time physically-based graphics engine using c++23 and Vulkan - the next generation graphics API.\u003c/p\u003e\n\u003ch2 id=\"about-this-project\"\u003eAbout this project\u003c/h2\u003e\n\u003cp\u003eI\u0026rsquo;ve always enjoyed playing video games, but not quite like everyone else. While most people are immersed in the gameplay, I’ve always been curious about what’s happening under the hood. How do these games keep looking better and better? How is it even possible to render such detailed worlds on everyday hardware? These questions have fascinated me for as long as I can remember.\u003c/p\u003e","title":"Hammock - Vulkan graphics engine"},{"content":"This project aims to make creation of a window with a Vulkan surface and basic event handling as simple and portable as possible. If you just need to open a simple window with basing event/input handling for your Vulkan projects, this is the tool you need. Library is header-only single file and there is no need for implementation files. Just drop it into you project.\nSimple API The window API was made so it is as simple as possible. Open a window and create a VkSurface in just two lines:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #define SURFER_PLATFORM_X11 #include \u0026#34;VulkanSurfer.h\u0026#34; // Create a window Surfer::Window * window = Surfer::Window::createWindow(\u0026#34;Example window\u0026#34;, instance, 800, 600 , 100, 100 ); // Get the surface VkSurfaceKHR surface = window-\u0026gt;getSurface(); // Draw while (!window-\u0026gt;shouldClose()) { // poll for events window-\u0026gt;pollEvents(); // do your rendering } // Don\u0026#39;t forget to destroy the window Surfer::Window::destroyWindow(window); See the full example here.\nCallback-based event handling Event handling is done using simple callback system.\n1 2 3 window-\u0026gt;registerKeyPressCallback([](Surfer::KeyCode key) { std::cout \u0026lt;\u0026lt; \u0026#34;Key pressed \u0026#34; \u0026lt;\u0026lt; static_cast\u0026lt;unsigned int\u0026gt;(key) \u0026lt;\u0026lt; std::endl; }); About this project In graphics engines and renderers, window management and event handling is often a necessary but tedious task. Most developers choose to abstract this functionality using libraries like GLFW, SDL, or similar tools. While these libraries are robust and feature-rich, they tend to be heavyweight and require installation via NuGet, vcpkg, or manual downloads. This can impact the portability of projects that rely on them.\nAs a researcher and graphics programming enthusiast, my needs are simpler. I primarily need a window for the rendering surface and basic input handling—just enough to close the window with the Esc key or enable basic camera movement. For such straightforward requirements, using a large library often feels like overkill. Don’t get me wrong—SDL2 is excellent, and GLFW is truly amazing. But for smaller projects, their size and complexity can be unnecessary.\nWhen I looked for lightweight, single-header alternatives, I was surprised to find a lack of options tailored to Vulkan. The OpenGL ecosystem has plenty of solutions, but Vulkan seems to have been overlooked in this area. That’s why I decided to create my own solution.\nWhat started as a utility extracted from my renderer has evolved into a portable, single-header window library designed specifically for Vulkan. It’s simple, lightweight, and focuses on exactly what’s needed—nothing more, nothing less.\nYou can find the source code in the official repository.\n","permalink":"http://localhost:1313/projects/surfer/","summary":"\u003cp\u003eThis \u003ca href=\"https://github.com/elliahu/VulkanSurfer\"\u003eproject\u003c/a\u003e aims to make creation of a window with a Vulkan surface and basic event handling as simple and portable as possible. If you just need to open a simple window with basing event/input handling for your Vulkan projects, this is the tool you need. Library is header-only single file and there is no need for implementation files. Just drop it into you project.\u003c/p\u003e\n\u003ch2 id=\"simple-api\"\u003eSimple API\u003c/h2\u003e\n\u003cp\u003eThe window API was made so it is as simple as possible. Open a window and create a VkSurface in just two lines:\u003c/p\u003e","title":"VulkanSurfer - minimal window library for Vulkan"},{"content":"I’ve always approached video games a little differently than most. While others get caught up in the gameplay, I’ve always been drawn to what’s happening behind the scenes. How do these stunning visuals keep pushing boundaries year after year? How is it possible to render such detailed, lifelike worlds on everyday hardware? These questions didn’t just pique my curiosity—they shaped my career.\nAs a software engineer, I’ve channeled this fascination into understanding the technology that powers computer graphics. From shaders and rendering pipelines to real-time lighting and optimization, I’m passionate about breaking down how it all works and building systems that bring these concepts to life. For me, the process of creating visuals is as exciting as seeing the finished result on the screen.\nI still remember playing Horizon Forbidden West on the PS5 and being completely mesmerized—not by the action-packed gameplay, but by a simple patch of moss. I spent over an hour studying its texture, lighting, and tiny imperfections, captivated by how convincingly real it looked. That moment crystallized what drives me: a deep appreciation for the artistry and engineering behind computer graphics.\nMy curiosity doesn’t stop at games. Whether it’s architectural visualization, virtual reality, or scientific simulations, I’m inspired by how computer graphics blend creativity and technology to shape the way we see and interact with digital worlds. As both a software engineer and a graphics enthusiast, I’m committed to pushing the boundaries of what’s possible and contributing to the incredible visual experiences that define our era.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’ve always approached video games a little differently than most. While others get caught up in the gameplay, I’ve always been drawn to what’s happening behind the scenes. How do these stunning visuals keep pushing boundaries year after year? How is it possible to render such detailed, lifelike worlds on everyday hardware? These questions didn’t just pique my curiosity—they shaped my career.\u003c/p\u003e\n\u003cp\u003eAs a software engineer, I’ve channeled this fascination into understanding the technology that powers computer graphics. From shaders and rendering pipelines to real-time lighting and optimization, I’m passionate about breaking down how it all works and building systems that bring these concepts to life. For me, the process of creating visuals is as exciting as seeing the finished result on the screen.\u003c/p\u003e","title":"About me"},{"content":"Custom real-time physically-based graphics engine using c++23 and Vulkan - the next generation graphics API.\nAbout this project I\u0026rsquo;ve always enjoyed playing video games, but not quite like everyone else. While most people are immersed in the gameplay, I’ve always been curious about what’s happening under the hood. How do these games keep looking better and better? How is it even possible to render such detailed worlds on everyday hardware? These questions have fascinated me for as long as I can remember.\nOnce, while playing Horizon Forbidden West on the PS5, I spent over an hour just staring at a patch of moss—completely captivated by how realistic it looked. That’s who I am: someone who’s endlessly intrigued by the technology powering the visuals.\nMy first real hands-on experience with computer graphics was during university. While the professor wasn’t exactly the most approachable person, I thoroughly enjoyed the lectures. What I love most about computer graphics is how theory and practice come together to create something tangible—something you can see and interact with.\nI started my graphics programming journey with OpenGL, learning the basics and building a strong foundation. At some point, for no particular reason other than that it sounded cool, I decided to dive into Vulkan. Many years (and countless challenges) later, here I am, working on a Vulkan-based graphics engine. It’s been a long road filled with sweat, tears, and plenty of late nights, but I’m proud of what I’ve accomplished so far.\nThe project is still a work in progress—there are parts of the code that need serious rewrites—but every day it gets better. And to me, that’s the exciting part: the process of creating, learning, and improving.\nYou can find the source code and more information in the official repository.\nScreenshots Here you can screenshots from some of my rendering endeavors using the Hammock. ","permalink":"http://localhost:1313/projects/hammock/","summary":"\u003cp\u003eCustom real-time physically-based graphics engine using c++23 and Vulkan - the next generation graphics API.\u003c/p\u003e\n\u003ch2 id=\"about-this-project\"\u003eAbout this project\u003c/h2\u003e\n\u003cp\u003eI\u0026rsquo;ve always enjoyed playing video games, but not quite like everyone else. While most people are immersed in the gameplay, I’ve always been curious about what’s happening under the hood. How do these games keep looking better and better? How is it even possible to render such detailed worlds on everyday hardware? These questions have fascinated me for as long as I can remember.\u003c/p\u003e","title":"Hammock - Vulkan graphics engine"},{"content":"This project aims to make creation of a window with a Vulkan surface and basic event handling as simple and portable as possible. If you just need to open a simple window with basing event/input handling for your Vulkan projects, this is the tool you need. Library is header-only single file and there is no need for implementation files. Just drop it into you project.\nSimple API The window API was made so it is as simple as possible. Open a window and create a VkSurface in just two lines:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #define SURFER_PLATFORM_X11 #include \u0026#34;VulkanSurfer.h\u0026#34; // Create a window Surfer::Window * window = Surfer::Window::createWindow(\u0026#34;Example window\u0026#34;, instance, 800, 600 , 100, 100 ); // Get the surface VkSurfaceKHR surface = window-\u0026gt;getSurface(); // Draw while (!window-\u0026gt;shouldClose()) { // poll for events window-\u0026gt;pollEvents(); // do your rendering } // Don\u0026#39;t forget to destroy the window Surfer::Window::destroyWindow(window); See the full example here.\nCallback-based event handling Event handling is done using simple callback system.\n1 2 3 window-\u0026gt;registerKeyPressCallback([](Surfer::KeyCode key) { std::cout \u0026lt;\u0026lt; \u0026#34;Key pressed \u0026#34; \u0026lt;\u0026lt; static_cast\u0026lt;unsigned int\u0026gt;(key) \u0026lt;\u0026lt; std::endl; }); About this project In graphics engines and renderers, window management and event handling is often a necessary but tedious task. Most developers choose to abstract this functionality using libraries like GLFW, SDL, or similar tools. While these libraries are robust and feature-rich, they tend to be heavyweight and require installation via NuGet, vcpkg, or manual downloads. This can impact the portability of projects that rely on them.\nAs a researcher and graphics programming enthusiast, my needs are simpler. I primarily need a window for the rendering surface and basic input handling—just enough to close the window with the Esc key or enable basic camera movement. For such straightforward requirements, using a large library often feels like overkill. Don’t get me wrong—SDL2 is excellent, and GLFW is truly amazing. But for smaller projects, their size and complexity can be unnecessary.\nWhen I looked for lightweight, single-header alternatives, I was surprised to find a lack of options tailored to Vulkan. The OpenGL ecosystem has plenty of solutions, but Vulkan seems to have been overlooked in this area. That’s why I decided to create my own solution.\nWhat started as a utility extracted from my renderer has evolved into a portable, single-header window library designed specifically for Vulkan. It’s simple, lightweight, and focuses on exactly what’s needed—nothing more, nothing less.\nYou can find the source code in the official repository.\n","permalink":"http://localhost:1313/projects/surfer/","summary":"\u003cp\u003eThis \u003ca href=\"https://github.com/elliahu/VulkanSurfer\"\u003eproject\u003c/a\u003e aims to make creation of a window with a Vulkan surface and basic event handling as simple and portable as possible. If you just need to open a simple window with basing event/input handling for your Vulkan projects, this is the tool you need. Library is header-only single file and there is no need for implementation files. Just drop it into you project.\u003c/p\u003e\n\u003ch2 id=\"simple-api\"\u003eSimple API\u003c/h2\u003e\n\u003cp\u003eThe window API was made so it is as simple as possible. Open a window and create a VkSurface in just two lines:\u003c/p\u003e","title":"VulkanSurfer - minimal window library for Vulkan"},{"content":"I’ve always approached video games a little differently than most. While others get caught up in the gameplay, I’ve always been drawn to what’s happening behind the scenes. How do these stunning visuals keep pushing boundaries year after year? How is it possible to render such detailed, lifelike worlds on everyday hardware? These questions didn’t just pique my curiosity—they shaped my career.\nAs a software engineer, I’ve channeled this fascination into understanding the technology that powers computer graphics. From shaders and rendering pipelines to real-time lighting and optimization, I’m passionate about breaking down how it all works and building systems that bring these concepts to life. For me, the process of creating visuals is as exciting as seeing the finished result on the screen.\nI still remember playing Horizon Forbidden West on the PS5 and being completely mesmerized—not by the action-packed gameplay, but by a simple patch of moss. I spent over an hour studying its texture, lighting, and tiny imperfections, captivated by how convincingly real it looked. That moment crystallized what drives me: a deep appreciation for the artistry and engineering behind computer graphics.\nMy curiosity doesn’t stop at games. Whether it’s architectural visualization, virtual reality, or scientific simulations, I’m inspired by how computer graphics blend creativity and technology to shape the way we see and interact with digital worlds. As both a software engineer and a graphics enthusiast, I’m committed to pushing the boundaries of what’s possible and contributing to the incredible visual experiences that define our era.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’ve always approached video games a little differently than most. While others get caught up in the gameplay, I’ve always been drawn to what’s happening behind the scenes. How do these stunning visuals keep pushing boundaries year after year? How is it possible to render such detailed, lifelike worlds on everyday hardware? These questions didn’t just pique my curiosity—they shaped my career.\u003c/p\u003e\n\u003cp\u003eAs a software engineer, I’ve channeled this fascination into understanding the technology that powers computer graphics. From shaders and rendering pipelines to real-time lighting and optimization, I’m passionate about breaking down how it all works and building systems that bring these concepts to life. For me, the process of creating visuals is as exciting as seeing the finished result on the screen.\u003c/p\u003e","title":"About me"},{"content":"Custom real-time physically-based graphics engine using c++23 and Vulkan - the next generation graphics API.\nAbout this project I\u0026rsquo;ve always enjoyed playing video games, but not quite like everyone else. While most people are immersed in the gameplay, I’ve always been curious about what’s happening under the hood. How do these games keep looking better and better? How is it even possible to render such detailed worlds on everyday hardware? These questions have fascinated me for as long as I can remember.\nOnce, while playing Horizon Forbidden West on the PS5, I spent over an hour just staring at a patch of moss—completely captivated by how realistic it looked. That’s who I am: someone who’s endlessly intrigued by the technology powering the visuals.\nMy first real hands-on experience with computer graphics was during university. While the professor wasn’t exactly the most approachable person, I thoroughly enjoyed the lectures. What I love most about computer graphics is how theory and practice come together to create something tangible—something you can see and interact with.\nI started my graphics programming journey with OpenGL, learning the basics and building a strong foundation. At some point, for no particular reason other than that it sounded cool, I decided to dive into Vulkan. Many years (and countless challenges) later, here I am, working on a Vulkan-based graphics engine. It’s been a long road filled with sweat, tears, and plenty of late nights, but I’m proud of what I’ve accomplished so far.\nThe project is still a work in progress—there are parts of the code that need serious rewrites—but every day it gets better. And to me, that’s the exciting part: the process of creating, learning, and improving.\nYou can find the source code and more information in the official repository.\nScreenshots Here you can screenshots from some of my rendering endeavors using the Hammock. ","permalink":"http://localhost:1313/projects/hammock/","summary":"\u003cp\u003eCustom real-time physically-based graphics engine using c++23 and Vulkan - the next generation graphics API.\u003c/p\u003e\n\u003ch2 id=\"about-this-project\"\u003eAbout this project\u003c/h2\u003e\n\u003cp\u003eI\u0026rsquo;ve always enjoyed playing video games, but not quite like everyone else. While most people are immersed in the gameplay, I’ve always been curious about what’s happening under the hood. How do these games keep looking better and better? How is it even possible to render such detailed worlds on everyday hardware? These questions have fascinated me for as long as I can remember.\u003c/p\u003e","title":"Hammock - Vulkan graphics engine"},{"content":"This project aims to make creation of a window with a Vulkan surface and basic event handling as simple and portable as possible. If you just need to open a simple window with basing event/input handling for your Vulkan projects, this is the tool you need. Library is header-only single file and there is no need for implementation files. Just drop it into you project.\nSimple API The window API was made so it is as simple as possible. Open a window and create a VkSurface in just two lines:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #define SURFER_PLATFORM_X11 #include \u0026#34;VulkanSurfer.h\u0026#34; // Create a window Surfer::Window * window = Surfer::Window::createWindow(\u0026#34;Example window\u0026#34;, instance, 800, 600 , 100, 100 ); // Get the surface VkSurfaceKHR surface = window-\u0026gt;getSurface(); // Draw while (!window-\u0026gt;shouldClose()) { // poll for events window-\u0026gt;pollEvents(); // do your rendering } // Don\u0026#39;t forget to destroy the window Surfer::Window::destroyWindow(window); See the full example here.\nCallback-based event handling Event handling is done using simple callback system.\n1 2 3 window-\u0026gt;registerKeyPressCallback([](Surfer::KeyCode key) { std::cout \u0026lt;\u0026lt; \u0026#34;Key pressed \u0026#34; \u0026lt;\u0026lt; static_cast\u0026lt;unsigned int\u0026gt;(key) \u0026lt;\u0026lt; std::endl; }); About this project In graphics engines and renderers, window management and event handling is often a necessary but tedious task. Most developers choose to abstract this functionality using libraries like GLFW, SDL, or similar tools. While these libraries are robust and feature-rich, they tend to be heavyweight and require installation via NuGet, vcpkg, or manual downloads. This can impact the portability of projects that rely on them.\nAs a researcher and graphics programming enthusiast, my needs are simpler. I primarily need a window for the rendering surface and basic input handling—just enough to close the window with the Esc key or enable basic camera movement. For such straightforward requirements, using a large library often feels like overkill. Don’t get me wrong—SDL2 is excellent, and GLFW is truly amazing. But for smaller projects, their size and complexity can be unnecessary.\nWhen I looked for lightweight, single-header alternatives, I was surprised to find a lack of options tailored to Vulkan. The OpenGL ecosystem has plenty of solutions, but Vulkan seems to have been overlooked in this area. That’s why I decided to create my own solution.\nWhat started as a utility extracted from my renderer has evolved into a portable, single-header window library designed specifically for Vulkan. It’s simple, lightweight, and focuses on exactly what’s needed—nothing more, nothing less.\nYou can find the source code in the official repository.\n","permalink":"http://localhost:1313/projects/surfer/","summary":"\u003cp\u003eThis \u003ca href=\"https://github.com/elliahu/VulkanSurfer\"\u003eproject\u003c/a\u003e aims to make creation of a window with a Vulkan surface and basic event handling as simple and portable as possible. If you just need to open a simple window with basing event/input handling for your Vulkan projects, this is the tool you need. Library is header-only single file and there is no need for implementation files. Just drop it into you project.\u003c/p\u003e\n\u003ch2 id=\"simple-api\"\u003eSimple API\u003c/h2\u003e\n\u003cp\u003eThe window API was made so it is as simple as possible. Open a window and create a VkSurface in just two lines:\u003c/p\u003e","title":"VulkanSurfer - minimal window library for Vulkan"},{"content":"I’ve always approached video games a little differently than most. While others get caught up in the gameplay, I’ve always been drawn to what’s happening behind the scenes. How do these stunning visuals keep pushing boundaries year after year? How is it possible to render such detailed, lifelike worlds on everyday hardware? These questions didn’t just pique my curiosity—they shaped my career.\nAs a software engineer, I’ve channeled this fascination into understanding the technology that powers computer graphics. From shaders and rendering pipelines to real-time lighting and optimization, I’m passionate about breaking down how it all works and building systems that bring these concepts to life. For me, the process of creating visuals is as exciting as seeing the finished result on the screen.\nI still remember playing Horizon Forbidden West on the PS5 and being completely mesmerized—not by the action-packed gameplay, but by a simple patch of moss. I spent over an hour studying its texture, lighting, and tiny imperfections, captivated by how convincingly real it looked. That moment crystallized what drives me: a deep appreciation for the artistry and engineering behind computer graphics.\nMy curiosity doesn’t stop at games. Whether it’s architectural visualization, virtual reality, or scientific simulations, I’m inspired by how computer graphics blend creativity and technology to shape the way we see and interact with digital worlds. As both a software engineer and a graphics enthusiast, I’m committed to pushing the boundaries of what’s possible and contributing to the incredible visual experiences that define our era.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’ve always approached video games a little differently than most. While others get caught up in the gameplay, I’ve always been drawn to what’s happening behind the scenes. How do these stunning visuals keep pushing boundaries year after year? How is it possible to render such detailed, lifelike worlds on everyday hardware? These questions didn’t just pique my curiosity—they shaped my career.\u003c/p\u003e\n\u003cp\u003eAs a software engineer, I’ve channeled this fascination into understanding the technology that powers computer graphics. From shaders and rendering pipelines to real-time lighting and optimization, I’m passionate about breaking down how it all works and building systems that bring these concepts to life. For me, the process of creating visuals is as exciting as seeing the finished result on the screen.\u003c/p\u003e","title":"About me"},{"content":"Custom real-time physically-based graphics engine using c++23 and Vulkan - the next generation graphics API.\nAbout this project I\u0026rsquo;ve always enjoyed playing video games, but not quite like everyone else. While most people are immersed in the gameplay, I’ve always been curious about what’s happening under the hood. How do these games keep looking better and better? How is it even possible to render such detailed worlds on everyday hardware? These questions have fascinated me for as long as I can remember.\nOnce, while playing Horizon Forbidden West on the PS5, I spent over an hour just staring at a patch of moss—completely captivated by how realistic it looked. That’s who I am: someone who’s endlessly intrigued by the technology powering the visuals.\nMy first real hands-on experience with computer graphics was during university. While the professor wasn’t exactly the most approachable person, I thoroughly enjoyed the lectures. What I love most about computer graphics is how theory and practice come together to create something tangible—something you can see and interact with.\nI started my graphics programming journey with OpenGL, learning the basics and building a strong foundation. At some point, for no particular reason other than that it sounded cool, I decided to dive into Vulkan. Many years (and countless challenges) later, here I am, working on a Vulkan-based graphics engine. It’s been a long road filled with sweat, tears, and plenty of late nights, but I’m proud of what I’ve accomplished so far.\nThe project is still a work in progress—there are parts of the code that need serious rewrites—but every day it gets better. And to me, that’s the exciting part: the process of creating, learning, and improving.\nYou can find the source code and more information in the official repository.\nScreenshots Here you can screenshots from some of my rendering endeavors using the Hammock. ","permalink":"http://localhost:1313/projects/hammock/","summary":"\u003cp\u003eCustom real-time physically-based graphics engine using c++23 and Vulkan - the next generation graphics API.\u003c/p\u003e\n\u003ch2 id=\"about-this-project\"\u003eAbout this project\u003c/h2\u003e\n\u003cp\u003eI\u0026rsquo;ve always enjoyed playing video games, but not quite like everyone else. While most people are immersed in the gameplay, I’ve always been curious about what’s happening under the hood. How do these games keep looking better and better? How is it even possible to render such detailed worlds on everyday hardware? These questions have fascinated me for as long as I can remember.\u003c/p\u003e","title":"Hammock - Vulkan graphics engine"},{"content":"This project aims to make creation of a window with a Vulkan surface and basic event handling as simple and portable as possible. If you just need to open a simple window with basing event/input handling for your Vulkan projects, this is the tool you need. Library is header-only single file and there is no need for implementation files. Just drop it into you project.\nSimple API The window API was made so it is as simple as possible. Open a window and create a VkSurface in just two lines:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #define SURFER_PLATFORM_X11 #include \u0026#34;VulkanSurfer.h\u0026#34; // Create a window Surfer::Window * window = Surfer::Window::createWindow(\u0026#34;Example window\u0026#34;, instance, 800, 600 , 100, 100 ); // Get the surface VkSurfaceKHR surface = window-\u0026gt;getSurface(); // Draw while (!window-\u0026gt;shouldClose()) { // poll for events window-\u0026gt;pollEvents(); // do your rendering } // Don\u0026#39;t forget to destroy the window Surfer::Window::destroyWindow(window); See the full example here.\nCallback-based event handling Event handling is done using simple callback system.\n1 2 3 window-\u0026gt;registerKeyPressCallback([](Surfer::KeyCode key) { std::cout \u0026lt;\u0026lt; \u0026#34;Key pressed \u0026#34; \u0026lt;\u0026lt; static_cast\u0026lt;unsigned int\u0026gt;(key) \u0026lt;\u0026lt; std::endl; }); About this project In graphics engines and renderers, window management and event handling is often a necessary but tedious task. Most developers choose to abstract this functionality using libraries like GLFW, SDL, or similar tools. While these libraries are robust and feature-rich, they tend to be heavyweight and require installation via NuGet, vcpkg, or manual downloads. This can impact the portability of projects that rely on them.\nAs a researcher and graphics programming enthusiast, my needs are simpler. I primarily need a window for the rendering surface and basic input handling—just enough to close the window with the Esc key or enable basic camera movement. For such straightforward requirements, using a large library often feels like overkill. Don’t get me wrong—SDL2 is excellent, and GLFW is truly amazing. But for smaller projects, their size and complexity can be unnecessary.\nWhen I looked for lightweight, single-header alternatives, I was surprised to find a lack of options tailored to Vulkan. The OpenGL ecosystem has plenty of solutions, but Vulkan seems to have been overlooked in this area. That’s why I decided to create my own solution.\nWhat started as a utility extracted from my renderer has evolved into a portable, single-header window library designed specifically for Vulkan. It’s simple, lightweight, and focuses on exactly what’s needed—nothing more, nothing less.\nYou can find the source code in the official repository.\n","permalink":"http://localhost:1313/projects/surfer/","summary":"\u003cp\u003eThis \u003ca href=\"https://github.com/elliahu/VulkanSurfer\"\u003eproject\u003c/a\u003e aims to make creation of a window with a Vulkan surface and basic event handling as simple and portable as possible. If you just need to open a simple window with basing event/input handling for your Vulkan projects, this is the tool you need. Library is header-only single file and there is no need for implementation files. Just drop it into you project.\u003c/p\u003e\n\u003ch2 id=\"simple-api\"\u003eSimple API\u003c/h2\u003e\n\u003cp\u003eThe window API was made so it is as simple as possible. Open a window and create a VkSurface in just two lines:\u003c/p\u003e","title":"VulkanSurfer - minimal window library for Vulkan"},{"content":"I’ve always approached video games a little differently than most. While others get caught up in the gameplay, I’ve always been drawn to what’s happening behind the scenes. How do these stunning visuals keep pushing boundaries year after year? How is it possible to render such detailed, lifelike worlds on everyday hardware? These questions didn’t just pique my curiosity—they shaped my career.\nAs a software engineer, I’ve channeled this fascination into understanding the technology that powers computer graphics. From shaders and rendering pipelines to real-time lighting and optimization, I’m passionate about breaking down how it all works and building systems that bring these concepts to life. For me, the process of creating visuals is as exciting as seeing the finished result on the screen.\nI still remember playing Horizon Forbidden West on the PS5 and being completely mesmerized—not by the action-packed gameplay, but by a simple patch of moss. I spent over an hour studying its texture, lighting, and tiny imperfections, captivated by how convincingly real it looked. That moment crystallized what drives me: a deep appreciation for the artistry and engineering behind computer graphics.\nMy curiosity doesn’t stop at games. Whether it’s architectural visualization, virtual reality, or scientific simulations, I’m inspired by how computer graphics blend creativity and technology to shape the way we see and interact with digital worlds. As both a software engineer and a graphics enthusiast, I’m committed to pushing the boundaries of what’s possible and contributing to the incredible visual experiences that define our era.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’ve always approached video games a little differently than most. While others get caught up in the gameplay, I’ve always been drawn to what’s happening behind the scenes. How do these stunning visuals keep pushing boundaries year after year? How is it possible to render such detailed, lifelike worlds on everyday hardware? These questions didn’t just pique my curiosity—they shaped my career.\u003c/p\u003e\n\u003cp\u003eAs a software engineer, I’ve channeled this fascination into understanding the technology that powers computer graphics. From shaders and rendering pipelines to real-time lighting and optimization, I’m passionate about breaking down how it all works and building systems that bring these concepts to life. For me, the process of creating visuals is as exciting as seeing the finished result on the screen.\u003c/p\u003e","title":"About me"},{"content":"Custom real-time physically-based graphics engine using c++23 and Vulkan - the next generation graphics API.\nAbout this project I\u0026rsquo;ve always enjoyed playing video games, but not quite like everyone else. While most people are immersed in the gameplay, I’ve always been curious about what’s happening under the hood. How do these games keep looking better and better? How is it even possible to render such detailed worlds on everyday hardware? These questions have fascinated me for as long as I can remember.\nOnce, while playing Horizon Forbidden West on the PS5, I spent over an hour just staring at a patch of moss—completely captivated by how realistic it looked. That’s who I am: someone who’s endlessly intrigued by the technology powering the visuals.\nMy first real hands-on experience with computer graphics was during university. While the professor wasn’t exactly the most approachable person, I thoroughly enjoyed the lectures. What I love most about computer graphics is how theory and practice come together to create something tangible—something you can see and interact with.\nI started my graphics programming journey with OpenGL, learning the basics and building a strong foundation. At some point, for no particular reason other than that it sounded cool, I decided to dive into Vulkan. Many years (and countless challenges) later, here I am, working on a Vulkan-based graphics engine. It’s been a long road filled with sweat, tears, and plenty of late nights, but I’m proud of what I’ve accomplished so far.\nThe project is still a work in progress—there are parts of the code that need serious rewrites—but every day it gets better. And to me, that’s the exciting part: the process of creating, learning, and improving.\nYou can find the source code and more information in the official repository.\nScreenshots Here you can screenshots from some of my rendering endeavors using the Hammock. ","permalink":"http://localhost:1313/projects/hammock/","summary":"\u003cp\u003eCustom real-time physically-based graphics engine using c++23 and Vulkan - the next generation graphics API.\u003c/p\u003e\n\u003ch2 id=\"about-this-project\"\u003eAbout this project\u003c/h2\u003e\n\u003cp\u003eI\u0026rsquo;ve always enjoyed playing video games, but not quite like everyone else. While most people are immersed in the gameplay, I’ve always been curious about what’s happening under the hood. How do these games keep looking better and better? How is it even possible to render such detailed worlds on everyday hardware? These questions have fascinated me for as long as I can remember.\u003c/p\u003e","title":"Hammock - Vulkan graphics engine"},{"content":"This project aims to make creation of a window with a Vulkan surface and basic event handling as simple and portable as possible. If you just need to open a simple window with basing event/input handling for your Vulkan projects, this is the tool you need. Library is header-only single file and there is no need for implementation files. Just drop it into you project.\nSimple API The window API was made so it is as simple as possible. Open a window and create a VkSurface in just two lines:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #define SURFER_PLATFORM_X11 #include \u0026#34;VulkanSurfer.h\u0026#34; // Create a window Surfer::Window * window = Surfer::Window::createWindow(\u0026#34;Example window\u0026#34;, instance, 800, 600 , 100, 100 ); // Get the surface VkSurfaceKHR surface = window-\u0026gt;getSurface(); // Draw while (!window-\u0026gt;shouldClose()) { // poll for events window-\u0026gt;pollEvents(); // do your rendering } // Don\u0026#39;t forget to destroy the window Surfer::Window::destroyWindow(window); See the full example here.\nCallback-based event handling Event handling is done using simple callback system.\n1 2 3 window-\u0026gt;registerKeyPressCallback([](Surfer::KeyCode key) { std::cout \u0026lt;\u0026lt; \u0026#34;Key pressed \u0026#34; \u0026lt;\u0026lt; static_cast\u0026lt;unsigned int\u0026gt;(key) \u0026lt;\u0026lt; std::endl; }); About this project In graphics engines and renderers, window management and event handling is often a necessary but tedious task. Most developers choose to abstract this functionality using libraries like GLFW, SDL, or similar tools. While these libraries are robust and feature-rich, they tend to be heavyweight and require installation via NuGet, vcpkg, or manual downloads. This can impact the portability of projects that rely on them.\nAs a researcher and graphics programming enthusiast, my needs are simpler. I primarily need a window for the rendering surface and basic input handling—just enough to close the window with the Esc key or enable basic camera movement. For such straightforward requirements, using a large library often feels like overkill. Don’t get me wrong—SDL2 is excellent, and GLFW is truly amazing. But for smaller projects, their size and complexity can be unnecessary.\nWhen I looked for lightweight, single-header alternatives, I was surprised to find a lack of options tailored to Vulkan. The OpenGL ecosystem has plenty of solutions, but Vulkan seems to have been overlooked in this area. That’s why I decided to create my own solution.\nWhat started as a utility extracted from my renderer has evolved into a portable, single-header window library designed specifically for Vulkan. It’s simple, lightweight, and focuses on exactly what’s needed—nothing more, nothing less.\nYou can find the source code in the official repository.\n","permalink":"http://localhost:1313/projects/surfer/","summary":"\u003cp\u003eThis \u003ca href=\"https://github.com/elliahu/VulkanSurfer\"\u003eproject\u003c/a\u003e aims to make creation of a window with a Vulkan surface and basic event handling as simple and portable as possible. If you just need to open a simple window with basing event/input handling for your Vulkan projects, this is the tool you need. Library is header-only single file and there is no need for implementation files. Just drop it into you project.\u003c/p\u003e\n\u003ch2 id=\"simple-api\"\u003eSimple API\u003c/h2\u003e\n\u003cp\u003eThe window API was made so it is as simple as possible. Open a window and create a VkSurface in just two lines:\u003c/p\u003e","title":"VulkanSurfer - minimal window library for Vulkan"},{"content":"I’ve always approached video games a little differently than most. While others get caught up in the gameplay, I’ve always been drawn to what’s happening behind the scenes. How do these stunning visuals keep pushing boundaries year after year? How is it possible to render such detailed, lifelike worlds on everyday hardware? These questions didn’t just pique my curiosity—they shaped my career.\nAs a software engineer, I’ve channeled this fascination into understanding the technology that powers computer graphics. From shaders and rendering pipelines to real-time lighting and optimization, I’m passionate about breaking down how it all works and building systems that bring these concepts to life. For me, the process of creating visuals is as exciting as seeing the finished result on the screen.\nI still remember playing Horizon Forbidden West on the PS5 and being completely mesmerized—not by the action-packed gameplay, but by a simple patch of moss. I spent over an hour studying its texture, lighting, and tiny imperfections, captivated by how convincingly real it looked. That moment crystallized what drives me: a deep appreciation for the artistry and engineering behind computer graphics.\nMy curiosity doesn’t stop at games. Whether it’s architectural visualization, virtual reality, or scientific simulations, I’m inspired by how computer graphics blend creativity and technology to shape the way we see and interact with digital worlds. As both a software engineer and a graphics enthusiast, I’m committed to pushing the boundaries of what’s possible and contributing to the incredible visual experiences that define our era.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI’ve always approached video games a little differently than most. While others get caught up in the gameplay, I’ve always been drawn to what’s happening behind the scenes. How do these stunning visuals keep pushing boundaries year after year? How is it possible to render such detailed, lifelike worlds on everyday hardware? These questions didn’t just pique my curiosity—they shaped my career.\u003c/p\u003e\n\u003cp\u003eAs a software engineer, I’ve channeled this fascination into understanding the technology that powers computer graphics. From shaders and rendering pipelines to real-time lighting and optimization, I’m passionate about breaking down how it all works and building systems that bring these concepts to life. For me, the process of creating visuals is as exciting as seeing the finished result on the screen.\u003c/p\u003e","title":"About me"},{"content":"Custom real-time physically-based graphics engine using c++23 and Vulkan - the next generation graphics API.\nAbout this project I\u0026rsquo;ve always enjoyed playing video games, but not quite like everyone else. While most people are immersed in the gameplay, I’ve always been curious about what’s happening under the hood. How do these games keep looking better and better? How is it even possible to render such detailed worlds on everyday hardware? These questions have fascinated me for as long as I can remember.\nOnce, while playing Horizon Forbidden West on the PS5, I spent over an hour just staring at a patch of moss—completely captivated by how realistic it looked. That’s who I am: someone who’s endlessly intrigued by the technology powering the visuals.\nMy first real hands-on experience with computer graphics was during university. While the professor wasn’t exactly the most approachable person, I thoroughly enjoyed the lectures. What I love most about computer graphics is how theory and practice come together to create something tangible—something you can see and interact with.\nI started my graphics programming journey with OpenGL, learning the basics and building a strong foundation. At some point, for no particular reason other than that it sounded cool, I decided to dive into Vulkan. Many years (and countless challenges) later, here I am, working on a Vulkan-based graphics engine. It’s been a long road filled with sweat, tears, and plenty of late nights, but I’m proud of what I’ve accomplished so far.\nThe project is still a work in progress—there are parts of the code that need serious rewrites—but every day it gets better. And to me, that’s the exciting part: the process of creating, learning, and improving.\nYou can find the source code and more information in the official repository.\nScreenshots Here you can screenshots from some of my rendering endeavors using the Hammock. ","permalink":"http://localhost:1313/projects/hammock/","summary":"\u003cp\u003eCustom real-time physically-based graphics engine using c++23 and Vulkan - the next generation graphics API.\u003c/p\u003e\n\u003ch2 id=\"about-this-project\"\u003eAbout this project\u003c/h2\u003e\n\u003cp\u003eI\u0026rsquo;ve always enjoyed playing video games, but not quite like everyone else. While most people are immersed in the gameplay, I’ve always been curious about what’s happening under the hood. How do these games keep looking better and better? How is it even possible to render such detailed worlds on everyday hardware? These questions have fascinated me for as long as I can remember.\u003c/p\u003e","title":"Hammock - Vulkan graphics engine"},{"content":"This project aims to make creation of a window with a Vulkan surface and basic event handling as simple and portable as possible. If you just need to open a simple window with basing event/input handling for your Vulkan projects, this is the tool you need. Library is header-only single file and there is no need for implementation files. Just drop it into you project.\nSimple API The window API was made so it is as simple as possible. Open a window and create a VkSurface in just two lines:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #define SURFER_PLATFORM_X11 #include \u0026#34;VulkanSurfer.h\u0026#34; // Create a window Surfer::Window * window = Surfer::Window::createWindow(\u0026#34;Example window\u0026#34;, instance, 800, 600 , 100, 100 ); // Get the surface VkSurfaceKHR surface = window-\u0026gt;getSurface(); // Draw while (!window-\u0026gt;shouldClose()) { // poll for events window-\u0026gt;pollEvents(); // do your rendering } // Don\u0026#39;t forget to destroy the window Surfer::Window::destroyWindow(window); See the full example here.\nCallback-based event handling Event handling is done using simple callback system.\n1 2 3 window-\u0026gt;registerKeyPressCallback([](Surfer::KeyCode key) { std::cout \u0026lt;\u0026lt; \u0026#34;Key pressed \u0026#34; \u0026lt;\u0026lt; static_cast\u0026lt;unsigned int\u0026gt;(key) \u0026lt;\u0026lt; std::endl; }); About this project In graphics engines and renderers, window management and event handling is often a necessary but tedious task. Most developers choose to abstract this functionality using libraries like GLFW, SDL, or similar tools. While these libraries are robust and feature-rich, they tend to be heavyweight and require installation via NuGet, vcpkg, or manual downloads. This can impact the portability of projects that rely on them.\nAs a researcher and graphics programming enthusiast, my needs are simpler. I primarily need a window for the rendering surface and basic input handling—just enough to close the window with the Esc key or enable basic camera movement. For such straightforward requirements, using a large library often feels like overkill. Don’t get me wrong—SDL2 is excellent, and GLFW is truly amazing. But for smaller projects, their size and complexity can be unnecessary.\nWhen I looked for lightweight, single-header alternatives, I was surprised to find a lack of options tailored to Vulkan. The OpenGL ecosystem has plenty of solutions, but Vulkan seems to have been overlooked in this area. That’s why I decided to create my own solution.\nWhat started as a utility extracted from my renderer has evolved into a portable, single-header window library designed specifically for Vulkan. It’s simple, lightweight, and focuses on exactly what’s needed—nothing more, nothing less.\nYou can find the source code in the official repository.\n","permalink":"http://localhost:1313/projects/surfer/","summary":"\u003cp\u003eThis \u003ca href=\"https://github.com/elliahu/VulkanSurfer\"\u003eproject\u003c/a\u003e aims to make creation of a window with a Vulkan surface and basic event handling as simple and portable as possible. If you just need to open a simple window with basing event/input handling for your Vulkan projects, this is the tool you need. Library is header-only single file and there is no need for implementation files. Just drop it into you project.\u003c/p\u003e\n\u003ch2 id=\"simple-api\"\u003eSimple API\u003c/h2\u003e\n\u003cp\u003eThe window API was made so it is as simple as possible. Open a window and create a VkSurface in just two lines:\u003c/p\u003e","title":"VulkanSurfer - minimal window library for Vulkan"}]